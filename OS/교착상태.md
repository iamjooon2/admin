
![[데드락.png]]

## 교착상태란(Dead Lock)
- 2개 이상의 프로세스가 타 프로세스의 작업이 끝나기만 기다리며, 작업을 더 이상 진행하지 못하는 상태
- 아사 현상과는 다름
	- 아사 현상 : OS가 잘못된 정책을 사용하여 특정 프로세스 작업이 지연되는 형태
	- 교착 상태 : 여러 프로세스가 작업을 진행하며 자연스레 일어나는 상황
- 다른 프로세스와 공유할 수 없는 자원을 사용할 때 발생함
	- 공유 변수, 시스템 자원, 응용 프로그램 등등..

#### 자원할당 그래프
![[Pasted image 20240304144716.png]]
![[Pasted image 20240304144731.png]]


## 데드락의 필요조건
- 데드락은 아래의 상호 배제, 비선점, 점유와 대기, 원형 대기을 모두 충족해야 발생한다
	- *상호 배제(mutual exclusion)* : 프로세스가 사용하는 자원이 임계구역으로 보호돼, 다른 프로세스와 공유할 수 없는 배타적인 자원이여야 함
	- *비선점(non-preemption)* : 한 프로세스가 사용중인 자원은 중간에 다른 프로세스가 빼앗을 수 없음
	- *점유와 대기(hold and wait)* : 프로세스가 어떤 자원을 할당받은 상태에서 다른 자원을 기다리는 상태
	- *원형 대기(circular wait)* : 점유와 대기하는 프로세스간의 관계가 원을 이루어야 함, 프로세스들이 서로 방해하는 방향이 원을 이루면 프로세스들이 서로 양보하지 않아 데드락에 빠짐

### 식사하는 철학자 문제
- 식사하는 철학자 문제와 함께, 교착상태의 필요조건을 확인해보자

- 상호 배제: 포크는 한 사람이 사용하면 다른 사람이 사용할 수 없는 배타적인 자원임
- 비선점 : 다른 철학자가 포크를 사용하고 있다면, 해당 포크를 뺏을 수 없음
	- 둘 다 임계 구역과 관련있는데, 임계구역의 자원을 사용하는 프로세스들이 점유와 대기, 원형 대기 상황에 처하면 데드락이 발생
- 점유와 대기 : 한 철학자가 두 포크를 모두 점유하거나, 반대로 두 자원을 다 기다린다면 교착상태가 발생하지 않음
- 원형 대기: 동그란 식탁에서 밥을 먹는 것은, 선후관계를 결정할 수 없다는 것, 서로를 방해한다는 것

- 데드락과 아사 현상은 다르다
	- 아사 현상은 정책상의 잘못이나 오류로 인해 특정 프로세스의 작업이 이루어지지 않으나, 데드락은 자연적으로 발생
	

## 데드락 해결 방법

- 아래 네 가지 방법이 있다
	- *데드락 예방* : 데드락을 유발하는 네 조건을 무력화
		- 실효성이 적어 잘 사용하지 않음
	- *데드락 회피* : 데드락이 발생하지 않는 수준으로 자원을 할당
		- 자원 할당의 기준이 명확하지 않아 잘 사용 안함
	- *데드락 검출* : 자원 할당 그래프를 사용하여 데드락을 발견
	- *데드락 회복* : 데드락 검출 후 해결
		- 데드락을 검출한 후, 회복하는 방식으로 가장 많이 해결함

각각의 장단점은 다음과 같음
#### 교착 상태 예방
- 네 조건 중 하나라도 발생하지 않도록 막아 데드락을 막음
- 상호 배제 예방
	- 독점적으로 사용할 수 있는 자원을 없애는 것
	- 하지만 시스템 내에는 공유할 수 없는 자원이 있음 -> 사실상 어려움
- 비선점 예방
	- 모든 자원을 빼앗을 수 있도록 만듬
		- 어떤 기준으로 빼앗는지? 빼앗은 시간 중 얼마나 사용할지?
		- 아사 현상을 일으키기도 함
			- 아사 현상을 에이징으로도 해결할 수 있지만..
			- 우선순위 낮은 프로세스가 양보 끝에 자원 사용하면, 이 자원도 다시 비선점 자원이 돼 데드락에 빠질 수 있다
		-> 사실상 어렵다
- 점유와 대기 예방
	- 전부 할당하거나 아니면 아예 할당하지 않도록 함
	- 프로세스의 자원사용방식을 변경하는 방법인데, 아래와 같은 단점이 있다
		- 자신이 사용하는 모든 자원을 자세히 알기 어려움
		- 자원의 활용성 떨어짐
			- 앞으로 사용할 자원 미리 다 점유해버려서, 자원낭비 심해짐
		- 많은 자원을 사용하는 프로세스가 불리함
			- 동시에 많은 자원을 확보하기 어려워, 아사현상 말생
		- 결국 일괄 작업으로 동작
- 원형 대기 예방
	- 자원을 한 방향으로만 사용하도록 함(우선순서 부여), 이 또한 단점이 있음
		- 우선순위 부여 기준은 어떻게?
			- 어떤식으로 붙이든 자원 사용에 제약이 생김
#### 교착 상태 회피
- 자원을 기준에 따라 나눈 후, 교착상태가 발생하는지 파악하고 그 수준 이하로 자원을 나누어줌
-  안전한 상태를 유지할 수 있는 범위 내에서 자원을 할당해 교착상태를 피함

##### 은행원 알고리즘
- 프로세스에 기대 자원과 비교하여, 가용 자원이 하나라도 크거나 같으면 자원을 할당
- 가용 자원이 기대 자원보다 작다면, 하랑하지 않음

-  문제점
	- 프로세스가 자신이 사용할 모든 자원을 미리 선언해야 함
	- 시스템 전체 자원이 가변적이면 안 됨
	- 자원이 낭비된다
		- 실제로 데드락이 발생하지 않는데도, 발생할 것이라 예상하므로서 프로세스에 자원을 할당하는 데 제약을 둠
#### 교착 상태 검출
- 가장 현실적인 선택지, 예방은 구현 어렵고 회피는 자원낭비 심함

##### 타임아웃을 이용하는 방법
- 일정 시간동안 작업이 진행되지 않은 프로세스를 교착 상태로 간주하여 처리
- 대부분의 DB와 OS에서 많이 사용함(자원 할당 그래프가 작업 너무 많아 구현 어렵)
	- DB에서는 락을 걸기 전 체크 포인트(현재의 시스템 상태를 하드에 저장)를 걸어둔다

- 문제점
	- 엉뚱한 프로세스가 강제 종료될 수 있음
		- 데드락때문에만 작업을 쉬진 않음
	- 모든 시스템에 적용할 수 없다
		- 외부 API 콜의 경우 네트워크 등의 문제로 응답이 늦어진다면, 단순히 처리가 늦어지는지 확인 불가

##### 자원 할당 그래프를 이용하는 방법
- 그래프 그린 뒤 싸이클이 도는지 확인하는다
- 프로세스의 작업 방식을 제한하지 않으면서 데드락을 정확히 파악할 수 있음

- 문제점
	- 그래프 유지, 갱신, 검사도 비용이라서 오버헤드 발생

#### 교착 상태 회복
- 데드락 유발한 프로세스를 강제 종료함
- 모든 프로세스를 종료하거나, 프로세스를 기준에 맞추어 하나씩 골라 종료함

## 다중 자원과 교착 상태 검출
- 하나의 자원을 여러 개의 프로세스가 동시에 사용할 수 있는 경우에는 교착 상태 검출이 복잡함

### 다중 지원과 사이클
- 사이클 != 데드락
- ![[Pasted image 20240304193430.png]]
- P2가 사용하는 자원이 두 개이므로, P2가 작업을 마친 후 P1이 R2를 사용하여 작업을 마치면 됨

### 대기 그래프와 그래프 감소
- 자원 할당 그래프에서 프로세스 간에 기다리는 관계만 나타낸 뒤
	   자원이 끝날 가능성이 있는 프로세스부터 화살표를 연속적으로 지워나감
		   그래도 사이클이 돈다면, 그것은 데드락이다 
	   ![[Pasted image 20240304195042.png]]
	![[Pasted image 20240304195404.png]]