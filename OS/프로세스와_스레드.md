
## OS에서 프로세스란?

- _하나의 작업 단위_

하나의 프로그램이던 내가.. 마우스의 손길에 의해 프로세스가 돼버린다
- `저장장치에 있으면 프로그램`, `메모리에 올라오면 프로세스`

### 요리사 모형에 비유

- 운영체제에서의 프로세스가 구동되는 방식을 요리사 모형에 비유해보자

프로세스가 곧 → 요리사

첫번째 방식으로, `일괄 작업`으로 처리할 수 있다

- _한번에 하나의 작업을 처리하는 것_으로, 레스토랑에서 하나의 테이블만 있는 것과 진배없음 → 하나의 테이블에서 식사가 끝나고, 다른 식사 방식으로 적용 가능함
- 이때, 주문 목록은 Queue로 처리 가능함. 선입선출 순서대로

두번째 방식으로, `시분할 방식` 으로 처리할 수 있다

- 시간 절약 위해 한 손님이 식사하는 동안, 다른 손님의 요리를 만드는 방식
- CPU가 한 개인 컴퓨터에서 프로세스가 여러 상태를 오가며 실행하는 것도 같은 원리이다 (프로세스 → 요리사)

### 프로그램에서 프로세스로의 전환

- 프로세스는, 컴퓨터 시스템의 작업 단위로 `태스크`라고도 불림

전환시 프로세스는 다음과 같음

- 1. 운영체제는 프로그램을 메모리의 적당한 위치로 가져온다.
- 2. 그와 동시에 작업 지시서(PCB, Process Control Block)를 만든다
- 3. PCB는 프로세스를 처리하는 데 다양한 정보가 들어있다

_PCB에 들어있는 정보들은 다음과 같다_

- 프로세스 식별자 메모리에는 여러 개의 프로세스가 존재하므로, 각 프로세스를 구분하는 식
- 메모리 관련 정보 CPU는 실행하려는 프로세스가 메모리 어디에 있는지 알아야 하므로, PCB에는 메모리 위치 정보가 담겨있다
- 각종 중간값 시분할 시스템에서는 중간중간 돌아가면서 작업해야되기 때문에, 중간에 어디까지 작업했는지를 알아야 한다

PCB는 운영체제가 해당 프로세스를 위해 관리하는 데이터 구조이기 때문에, OS 영역에 만들어진다

**결국 프로세스는, 프로그램과 PCB가 함께 모여져있는 형태**이다

### 프로세스의 상태

- 다양한 목록의 주문서를 옮겨다니는 상황처럼, 운영체제에서도 여러 이유로 프로세스 상태가 변화된다
- 일괄 작업 시스템의 경우 프로세스가 생성된 후, CPU를 얻어 실행되고 작업을 마치면 종료됨(Create → Run → Terminate)

시분할 시스템에서의 상태는 다음과 같음

1. 생성 상태

- 프로세스가 메모리에 올라와 실행 준비를 마친 상태
- 이때, 프로세스 관리에 필요한 PCB가 생성됨

2. 준비 상태

- 생성된 프로세스가 메모리에 올라와 실행 준비를 완료한 상태
- 단일 CPU에서는 한번의 하나의 프로세스만 실행 가능함, 본인의 프로세스 실행 순서가 될 때까지 준비 상태에서 기다려야함

3. 실행 상태

- 준비 상태에 있는 프로세스중 하나가 CPU를 얻어, 실제 작업을 수행하는 상태
- 일정동안 CPU를 사용할 권리를 가지게 됨
- 다 주어진 시간을 사용하고도 작업이 끝나지 않았다면, 프로세스는 준비 상태로 돌아와 다음 차례를 기다림
- 프로세스는 대개 준비 상태 ↔ 실행 상태를 왔다 갔다 함

4. 대기 상태

- 실행 상태에 있는 프로세스가 입출력을 요청하면, 입출력이 완료될 때까지 기다리는 상태
- 이 상태에 있는 프로세스는 입출력장치별로 마련된 큐에서 기다린다
- 입출력이 완료되면 인터럽트가 발생하고, 대기상태에 있는 여러 프로세스 중 해당 인터럽트로 깨어날 프로세스를 찾는데, 이것이 `*wakeup(PID)*`임

5 ) 완료 상태

- 실행 상태의 프로세스가 주어진 시간 동안 작업을 마쳤을 때 진입
- 코드와 사용했던 데이터를 메모리에서 삭제하고, PCB를 폐기한다
- 정상적인 종료는 _`exit()`_ 으로 처리한다

## 프로세스 제어 블록과 문맥 교환

- 프로세스 제어 블록
    - 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료구조(==PCB)
- 모든 프로세스는 고유의 프로세스 제어 블록을 가지며, 프로세스 제어 블록은 프로세스 생성 시 만들어져서, 프로세스가 실행을 완료하면 폐기 됨

- 각각의 역할은 다음과 같음
- 포인터
    - PCB의 첫 번째 블록에는 포인터가 저장됨
    - 준비 상태나 대기 상태는 큐로 운영되는데, PCB를 연결하여 준비 상태나 대기 상태의 큐를 구현할 때 포인터를 사용한다
- 프로세스 상태
    - 생성, 준비, 실행, 대기, 보류 준비, 보류 대기등이 있음
    - PCB의 두번째 블록에 저장 됨
- 각종 레지스터 정보
    - 프로세스 제어 블록에는 프로세스가 실행되는 와중에 사용하던 레지스터 값이 포함됨
    - 이전에 실행할 때 사용한 레지스터의 값을 보관해야 다음에 실행할 수 있기에 항상 레지스터의 **중간값을 보관**
- 메모리 관리 정보
    - PCB에는 프로세스가 메모리의 어디에 있는지 나타내는 메모리 위치 정보, 메모리 보호를 위해 사용하는 경계 레지스터 값, 한계 레지스터 값이 저장 됨
    - 그 외 세그먼테이션 테이블, 페이지 테이블등의 정보도 보관함

### 포인터의 역할

- 같은 입출력을 기다리는 프로세스끼리 모여있는 상태는 다음과 같음

- 대기 상태에서 같은 입출력을 기다리는 프로세스의 PCB는 모두 동일한 대기 큐에 있기에 , PCB에서 포인터가 필요함

### 컨텍스트 스위칭

- 요리사가 요리 작업을 전환할 때, 단순히 주문서를 교환하는 것만으로 끝나지 않고, 이전 주문서를 내보내기 전에 사용한 재료와 도구를 치워야하는 작업에 비유 가능하다~
    
- 이 전환 과정은 주문서를 바꾸는 것과 동시에 작업 환경을 바꾸는 것과 같음
    
- 컨텍스트 스위칭(문맥 교환)은 **CPU를 차지하던 프로세스가 나가고, 새로운 프로세스를 받아들이는 작업**
    
    - 프로세스를 받아들이는 작업이, 두 프로세스의 PCB를 교환하는 작업이 됨
    
- 컨텍스트 스위칭은 다음과 같은 절차로 이루어 짐
    

-디스패치 : 준비 상태에 있던 프로세스가 CPU에 할당되는 것

- 컨텍스트 스위칭이 일어나는 경우
    - 한 프로세스가 자신에게 주어진 시간을 다 사용했을 때
    - 인터럽트가 걸렸을 때.. 등등이 있다

## 프로세스

### 프로세스 구조

- 코드 영역, 데이터 영역, 스택 영역으로 나누어짐

- 코드 영역(텍스트 영역)
    - 프로그램의 본문이 기술된 곳
    - 프로그래머가 작성한 프로그램이 이곳에 읽기 전용으로 탑재
- 데이터 영역
    - 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아놓는 곳
- 스택 영역
    - 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳
    - 프로세스 내에서 함수를 호출하면 _`function call`_ 함수를 수행하고, 원래 프로그램으로 되돌아올 위치를 이 영역에 저장함
    - 사용자한테는 보이지 않음

### 생성과 복사

- 프로세스는 프로그램을 실행할 때 새로 생성 됨
- 운영체제는 프로그램을 메모리로 가져와 코드 영역에 넣고, PCB를 생성함
- 메모리에 데이터 영역과 스택 영역을 확보한 후, 프로세스를 실행함

프로세스를 새로 생성하는 방법 뿐만 아니라, 실행중인 프로세스로부터 새로운 프로세스를 복사하는 방법도 있음 → `fork() 시스템 호출`

- fork() 시스템 호출
    - 실행중인 프로세스로부터 새로운 프로세스를 복사하는 함수
        - 똑같은 프로세스가 하나 더 만들어짐
    - 커널에서 제공, 일종의 시스템 호출
    - 새로 생성된 프로세스는 기존 프로세스의 자식이 된다

- 포크시 변경되는 부분은 다음와 같음
    
    - PID : 프로세스 구분자
    - 메모리 관련 정보 : 차지하고 있는 메모리 위치가 달라, 당연한 것
    - PPID(부모 프로세스 구분자)와 CPID(자식 프로세스 구분자) : 자식 프로세스가 없다면 CPID는 -1
- 장점
    
    - 디스크로부터 프로그램을 새로 가져오지 않고, 기존 메모리에서 복사하기 때문에, **프로세스 생성 속도가 빠르다**
    - 부모 프로세서가 사용하던 모든 자원을 추가 작업 없이 자식 프로세스에 상속 가능하여, **추가 작업 없이 자원을 상속할 수 있다**
    - **시스템 관리를 효율적으로 할 수 있음**
        - 부모 프로세스와 자식 프로세스가 각각 PPID, CPID로 연결되어, 자식프로세스를 종료하면 자식이 사용하던 자원을 메모리 영역, 파일, 하드웨어를 잘 정리할 수 있음

### 프로세스의 전환

- `exec()` 라는 함수로 이미 만들어진 프로세스 구조를 재활용하여, 새 프로세스로 전환할 수 있다
- 프로세스의 구조체를 재활용하기 위해 `exec()` 를 사용함
- 새로운 프로세스를 만들려면 PCB 만들고 메모리의 자리를 확보하는 과정, 프로세스 종료하고 GC하기 위해 상위 프로세스와 부모-자식 관계를 만들어야함
    - `exec()` 는 PCB, 메모리 영역, 부모-자식 관계를 다 사용할 수 있어 편리하다
    - 새로운 코드 영역만 가져오면 되기 때문에 OS의 작업이 수월함

- PID, PPID, CPID, 메모리 관련 사항은 변하지 않지만, 프로그램 카운터, 레지스터 값을 비롯한 각종 레지스터와 사용한 파일이 모두 리셋됨

### 계층 구조

- 유닉스에서 커널이 처음 메모리에 올라와 부팅이 되면, 커널 관련 프로세스를 여러개 만드는데, 그중 init 프로세스는 전체 프로세스의 출발점이 됨
- OS는 프로세스를 효율적으로 관리하기 위해 init 프로세스를 만들고, 나머지를 init 프로세스를 fork(), exec() 하여 자식 프로세스로 만든다

장점

- 여러 작업의 동시 처리
    
    - 인증을 거쳐 컴퓨터에 접속하는 login()이라는 프로세스가 있음
    - 사용자 세명이 동시에 컴퓨터에 접속한다면, 동시에 세 명을 처리해야하지만, 이 프로세스는 한 번에 한명만 처리할 수 있음 → 유닉스는 여러 사용자를 동시에 처리하기 위해 `fork()` 를 실행하여 login 프로세스를 여러개 만들고, 여러 사용자에게 나누어 줌
- 자원회수에 유리
    
    - 프로세스를 계층 구조로 만들면 프로세스 간의 책임 관계가 분명해져, 시스템 관리하기가 용이함
    - 자식 프로세스가 작업을 마쳤을 때, 사용하던 자원을 부모 프로세스가 회수하면 됨
    
    궁금한 점 : 그러면 자식 프로세스 종료 전에 부모프로세스가 먼저 종료되면 어캐처리하지?
    

고아 프로세스와 좀비 프로세스

- 부모 프로세스가 먼저 종료되어 비정상적으로 남아있는 프로세스를 고아 프로세스라 하고, 자식 프로세스가 종료되도 부모가 처리하지 않는 프로세스를 좀비 프로세스라 한다
- 컴퓨터 내 고아 혹은 좀비 프로세스가 많아지면 자원이 낭비되어 효율적 운영이 방해됨. 고로 주기적으로 반환 못한 자원을 회수하는 _자원회수_를 주기적으로 함
- C언어의 exit(), return이 자식프로세스가 작업이 끝났음을 부모 프로세스에 알리는 것임!

## 스레드

- 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위

### 프로세스와 스레드의 차이

- 서로서로 미치는 영향이 다르다
    
- 프로세스끼리는 약결합이지만, 스레드끼리는 프로세스 내에서 강결합
    
- 여러 프로세스로 구성된 멀티태스크와, 하나의 프로세스에 여러 개의 스레드로 구성된 멀티스레드의 차이는 아래와 같음
    

- 아래아 한글과 프린터는 서로 독립적으로 작용하다가, 서로 필요할 때 데이터를 주고받음
- 아래아 한글 내의 각각 작업들은, 동시에 작업을 함
    - 이런 스레드들은 강하게 연결되어있어, 아래아 한글이 종료되면 프로세스 내의 스레드도 같이 종료됨. 멀티스레드는 변수나 파일 등을 공유하고 전역 변수나 함수 호출등의 방법으로 스레드간 통신을 함

[테코톡 - 프로세스와 스레드 ](https://youtu.be/1grtWKqTn50?si=AFvpW6eg6iCLdWpX)

멀티스레드

- 프로세스 내 작업을 여러 개의 스레드로 분할하므로서, 작업의 부담을 줄이는 것
- 소프트웨어적인 방법

CPU 멀티스레드

- 한 번에 하나씩 처리해야 하는 여러 스레드를 파이프라인 기법을 이용하여 동시에 여러 스레드를 처리하도록 하는 병렬 처리 기법
- 하드웨어적인 방법

멀티태스킹

- 운영체제가 CPU에 작업(스레드 단위)를 줄 때, 시간을 잘게 나누어 배분하는 기법(시분할 시스템)

멀티프로세싱

- CPU를 여러개 사용해, 여러개의 스레드를 동시에 처리하는 작업 환경
- 하나의 컴퓨터에 CPU 혹은 CPU 내의 여러 코어에 스레드를 배정하여 동시에 작동하는 것

### 멀티스레드 구조

- 스레드는 멀티태스킹의 낭비 요소를 제거하기 위해 사용함.
    - 비슷한 일을 하는 프로세스를 `fork()` 하여 사용하면, 이 때의 코드 일부, PCB, 공유 변수가 여러 곳에 중복되어 메모리가 낭비됨
- 멀티스레드는, 데이터 등을 공유하면서 _**여러 개의 일을 하나의 프로세스 내에서 하는 것**_
- 프로세스는 크게 정적인 영역과 동적인 영역으로 구분됨
    - 멀티스레드는 정적인 영역을 프로세스 내의 스레드를 공유하고, 동적인 부분만 각각의 스레드에게 위임한다

멀티스레드를 사용한다면 독립적으로 실행 돼, 순서에 상관없이 출력 됨

### 멀티스레드의 장단점

- 장점
    - 응답성 향상 : 한 스레드가 입출력으로 인해 작업이 진행되지 않더라도 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빨리 응답 가능
    - 자원 공유 : 한 프로세스 내에서 독립적인 스레드를 생성하면 프로세스가 가진 자원을 모든 스레드가 공유하게 되어 작업을 원활하게 진행 가능
    - 효율성 향상 : 여러 프로세스를 생성하는 것과 달리 멀티스레드는 자원의 불필요한 중복을 막음으로서 시스템의 효율이 향상됨
    - 다중 CPU 지원 : 둘 이상의 PCU를 가진 컴퓨터에서 멀티스레드를 동시에 처리하여 CPU 사용량이 증가하고, 프로세스의 처리 시ㅏ간이 단축도미
- 단점
    - 한 스레드의 작업 결과가 전체 프로세스에 영향을 미칠 수 있음

### 멀티스레드 모델

프로세스는 커널 프로세스와 사용자 프로세스로 나뉘며, 스레드에도 `커널 스레드`와 `사용자 스레드`가 있다

사용자 스레드 : 라이브러리에 의해 구현된 일반적인 스레드

- 운영체제가 멀티스레드를 지원하지 않을 때 사용하는 방법으로, 초기의 스레드 시스템에서 이용됨
- 커널 입장에서는 일반 스레드지만, 커널이 하는 일을 라이브러리가 대신 처리하여 여러 스레드를 작동함
- 사용자 프로세스 내에 여러 개의 스레드가 존재하지만, 스레드 하나와 연결되기에 1 to N 모델이라 부름

- 라이브러리가 직접 스케줄링을 하고 작업에 필요한 정보를 처리하기 때문에 문맥 교환이 필요 없다.
- 문맥 교환을 하는 이유는, 시간을 나누어 서로 다른 프로세스를 처리하기 위해서임

-단점

- 여러 개의 스레드가 하나의 커널 스레드와 연결 되므로, 커널 스레드가 입출력 작업을 위해 **대기 상태에 들어가면 모든 사용자 스레드가 같이 대기하게 됨**
- 한 프로세스의 타임 슬라이스를 여러 스레드가 공유하기에, 여러 CPU를 동시에 스레드를 동시에 사용할 수 없다

커널 스레드 : 커널이 멀티스레드를 지원하는 방식

- 하나의 사용자 스레드가 하나의 커널 스레드와 연결되기 때문에 1 to 1 모델이라고 부른다.
- 커널 스레드는 독립적으로 스케쥴링이 되어, 특정 스레드가 대기 상태에 들어가도 다른 스레드는 작업을 계속 할 수 있음

-단점

- 컨텍스트 스위칭시 오버헤드 때문에 느리게 작동함

멀티레벨 스레드(하이브리드 스레드)

- 사용자 스레드와 커널 스레드를 혼합한 방식, M to N 모델
- 커널 스레드의 개수가 사용자 스레드보다 적기 때문에, 멀티레벨 스레드에서는 커널 스레드의 개수가 사용자 스레드보다 같거나 적다..

-단점
- 커널 스레드를 같이 사용하기 때문에 컨텍스트 스위치시 오버헤드가 있어 사용자 스레드만큼 빠르지 않음

## 동적 할당 영역과 시스템 호출
- 프로세스는 코드 영역, 데이터 영역, 스택 영역, 힙 영역이 있음

다시 한번 복습..

- 코드 영역: 프로그램의 본체가 있는 곳
- 데이터 영역: 프로그램이 사용하려고 정의한 변수와 데이터가 있는 곳
    - 포인터를 뺀 일반적인 변수는 선언시 그 크기가 결정됨

→ 고로 코드 영역과 데이터 영역은 실행되기 직전에 위치와 크기가 결정되고, 실행되는 동안 변하지 않아 정적 할당 영역이라 함

- 스택 영역과 힙 영역은 **프로세스가 실행되는 동안 만들어지는 영역**으로, 그 크기가 늘어났다가 줄어들기도 하여서.. 동적 할당 영역이다
    
- 스택 영역
    - 스택은 함수 호출시 두 가지 작업을 구현하기 위해 사용
    1. 호출한 함수가 종료되면, 함수를 호출하기 전 코드로 되돌아와야 하는데, *이때 돌아올 메모리의 주소*를 스택에 저장함
    2. 변수 사용 범위에 영향을 미치는 영역을 구현할 때 사용함
        
- 힙 영역
    
    - 힙은 동적으로 할당되는 변수 영역이다
    - 대개 데이터는 데이터 영역에 할당되고 크기가 정해지나, 일부데이터는 프로그램이 실행되는 동안 할당됨

### exit()

- exit() : 함수 맨 마지막에 exit(), return 을 사용하는 것은, 자식프로세스가 잘 끝났음을 부모 프로세스에게 알려주기 위함
- 반환값이 0이면 정상 종료, -1이면 정상 종료

### wait()

- OS가 부모 프로세스가 먼저 종료됨으로써 고아프로세스가 생기는 것을 방지하기 위해 사용
- 자식 프로세스가 끝나기를 기다렸다가, 자식 프로세스가 종료되면 다음 문장을 실행
- 부모 프로세스와 자식 프로세스간의 동기화에도 사용

### 전면프로세스와 후면프로세스

```bash
sleep 100     // 전면 프로세스
sleep 100&    // 후면 프로세스
```

- 전면 프로세스 : 작업이 끝날 때까지 쉘이 다음 명령어의 입력을 받아들이지 않는다!
    - 쉘이 wait() 함수를 사용 -> 자식프로세스 종료시까지 다음 명령어 받지 않고 대기
- 후면 프로세스 : 프로세스를 실행한 후 쉘이 바로 다음 명령어를 실행할 준비
    - wait()함수를 사용 안함 -> 다음 명령어 받을 수 있음