
프로세스는 시스템 내에서 독립적으로 실행되기도 하고, 데이터를 주고받으며 협업하기도 한다. 프로세스가 다른 프로세스와 데이터를 주고받는 프로세스 간 통신에는 같은 컴퓨터 내에 있는 프로세스뿐만 아니라 네트워크로 연결된 다른 컴퓨터에 있는 프로세스와의 통신도 포함된다.

- 전역변수나 파일을 이용하여 통신하는 것은 운영체제의 도움 없이 진행되는 통신 방식
- 파이프, 소켓, 원격 프로시저 호출은 운영체제가 제공하는 통신 방식

![[Pasted image 20240227124021.png]]

1) 프로세스 내부 데이터 통신 : 하나의 프로세스 내에 2개 이상의 스레드가 존재하는 경우
   프로스 내부의 스레드는 전역 변수나 파일을 이용하여 데이터를 주고받는다
2) 프로세스간 데이터 통신 : 공용 파일 또는 운영체제가 제공하는 파이프를 사용하여 통신
3) 여러 컴퓨터가 네트워크로 연결되어 있을 때는, 소켓을 이용하여 데이터를 주고받음(네트워킹)

#### 통신 방향에 따른 분류
데이터가 전송되는 방향에 따라 양방향 통신, 반양방향 통신, 단방향 통신으로 나뉜다
1. 양방향 통신: 데이터를 양쪽 방향에서 전송할 수 있는 구조. 프로세스간 통신에서는 소켓 통신이 양방향에 해당.
2. 반양방향 통신 : 데이터를 양쪽 방향으로 전송할 수 있지만, 동시 전송은 불가능하고 특정 시점에 한쪽 방향으로만 전송할 수 있는 구조(예 - 무전기)
3. 단방향 : 모스 신호처럼 한쪽 방향으로만 데이터를 전송할 수 있는 구조. 프로세스간 통신에서는 전역 변수와 파이프가 단방향 통신에 해당

대부분 통신은 양방향이지만, 전역 변수는 단방향 통신

#### 통신 구현 방식에 따른 분류
- 전역 변수를 사용하는 통신 방식의 가장 큰 문제는, 언제 데이터를 보낼지 그리고 데이터를 받는 쪽에서는 모른다는 것
- 고로 데이터를 받는 쪽에서는 반복적으로 전역 변수의 값을 점검하는 수밖에 없음
- 반복문을 무한 실행하면서 기다리는 것을 *busy waiting(바쁜 대기)* 라고 함(안좋은 프로그램의 전형적인 예)
- busy waiting을 해결하기 위해서는 데이터가 도착했음을 알려주는 동기화를 사용해야함
	- 프로세스간 통신은 동기화 기능이 있냐 없냐에 따라 blocking communication과 non-blocking communication으로 구분된다
		- 대기가 있는 통신(synchronous communication) : 동기화를 지원함. 데이터를 받는 쪽은 데이터가 도착할 때까지 자동으로 대기 상태에 머물러 있음
		- 대기가 없는 통신(asynchronous communication): 동기화 지원 X.
		 데이터를 받는 쪽은 busy waiting을 이용하여 데이터 도착했는지 여부를 직접 확인
### 프로세스간 통신의 종류
- 프로세스간 통신은 데이터를 주거나 받는 동작으로 이루어지며, 이는 쓰기연산과 읽기 연산으로 간소화 가능
#### 전역 변수를 이용한 통신
	- 공동으로 관리하는 메모리를 사용하여 데이터를 주고 받는 것
	- 데이터를 보내는 쪽에서는 전역 변수나 파일에 값을 쓰고, 데이터를 받는 쪽에서는 전역 변수의 값을 읽는다
	- 부모 프로세스가 전역 변수를 선언한 후, 자식 프로세스를 만들면 두 프로세스가 서로 통신 가능

![[Pasted image 20240227140257.png]]

다만 이 방식에서는 `프로세스 P`가 `전역변수 R`에 쓰기 연산을 한 후, 프로세스 C가 그 데이터를 읽으려 한다고 가정하면, 프로세스 P가 전역변수 R에 데이터를 언제 쓰는지 알 수 없음
*결국, 전역 변수의 값이 변할 때까지 busy waiting을 돌면서 계속 주시해야 함*


#### 파일을 이용한 통신

- 프로세스가 입출력 관리 프로세스에 쓰기를 요구하면 데이터가 저장되고, 읽기를 요구하면 i/o 프로세스로부터 데이터를 가져온다

![[Pasted image 20240227140747.png]]
- 파일을 이용한 통신은 부모-자식 고나계 프로세스간 통신에 많이 사용됨
- OS가 프로세스 동기화를 제공하지 않음
- 고로, 프로세스가 알아서 동기화를 해야하는데, 주로 부모 프로세스가 wait() 함수를 이용하여 자식 프로세스의 작업이 끝날 때까지 기다렸다가 작업을 시작함

#### 파이프를 이용한 통신
- 동기화 문제를 해결하는 방법이며, 단방향 통신
- 양방향 통신을 위해서는 파이프 두개를 사용해야 함
![[Pasted image 20240227141105.png]]

- 한 프로세스가 읽기 연산을 했는데, 다른 프로세스가 쓰기 연산을 하지 않았다면 첫번째 프로세스는 대기 상태가 된다
	- 다른 프로세스는 파이프에 대기 연산을 쓰는 순간 동기화가 이루어짐
- 이름 없는 파이프와 이름 있는 파이프로 나뉨
	- 이름 없는 파이프 : 일반적으로 파이프라고 하면 이름 없는 파이프를 가르킴
	- 부모와 자식 프로세스 혹은 같은 부모를 가진 자식 프로세스와 같이 서로 관련있는 프로세스간 통신에 사용됨
	- 이름 있는 파이프 : FIFO라 불리는 특수 파일을 이용하며, 서로 관련없는 프로세스 간 통신에 사용됨
#### 소켓을 이용한 통신
- 여러 컴퓨터에 있는 프로세스끼리도 통신(네트워킹)을 할 수 있음
- 양방향
- ![[Pasted image 20240227141445.png]]

- 소켓은 프로세스 동기화를 지원하므로 데이터를 받는 쪽의 프로세스가 busy waiting을 하지 않아도 됨


그래서 정리
- 프로세스 간에 데이터를 주고받는 행위는 읽기와 쓰기 연산
- 동기화를 지원하는 프로세스 간 통신에는 open()과  close() 함수가 사용됨
	- 전역변수는 동기화 기능이 없어서 open()과 close() 함수를 사용할 필요가 없으나, 나머지는 사용
	- 

## 공유 자원과 임계구역 

- **공유 자원** : 프로세스가 공동으로 이용하는 변수, 메모리 파일 등...
- 공동으로 사용 돼, 누가 언제 데이터를 읽거나 쓰냐에 따라 결과가 달라질 수 있어서 순서 보장이 필요함
	- **경쟁 조건(Race Condition)** : 2개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 상황
- **임계 구역(Critical Section)** : 공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역, 즉 *프로세스 실행 상황에서 공유할 수 없는 자원*...

#### 생산자-소비자 문제
- 생산자 프로세스는 물건을 생산하여 버퍼에 넣고, 소비자는 버퍼에서 물건을 가지고 온다 가정
- 버퍼에 들어가있는 물건 개수를 확인하기 위해 sum이라는 전역 변수를 사용함(상품 총 개수)
- 요건 생산 코드와 소비 코드가 동시에 입력됐을 때 문제가 생길 수 있음
	- 문제 생성되는 프로세스
	1. 생산자가 물건 하나를 buf 4에 저장함 (sum -> 4로는 아직 못바꿈)
	2. 소비자가 물건 하나를 소비함. (sum -> 2로는 못바꿈)
	3. 이때 1, 2가 동시에 실행된다면, 서로 바꾸는 걸 모른 채 sum = 3을 읽어서 작업 함
	4. 어떤게 실행되냐에 따라서 sum 값이 결정
	
  ![[Pasted image 20240227155022.png]]


- 임계 구역은 전역 변수뿐만이 아닌, 하드웨어 자원을 사용할 때도 적용되는 개념
- 하드웨어 자원도 한 번에 한 프로세스만 사용해야 함


해결하려면 세가지 조건을 만족해야 함
- **상호 배제(mutual exclusion)** : 한 프로세스가 임계구역에 들어가면, 다른 프로세스는 임계 구역에 들어갈 수 없음
- **한정 대기(bounded waiting)** : 어떤 프로세스도 무한대기(infinite postpone) 하지 않아야 함. 즉 특정 프로세스가 임계구역에 진입하지 못하면 안됨
- **진행의 융통성(progress flexibility)** : 한 프로세스가 다른 프로세스의 진행을 방해해서는 안 됨

## 임계구역 해결 방법

- 잠금, 잠금 해제, 동기화 구현 방법을 알아본다

```java 
public class Main {

	static boolean lock = false; // 공유 변수
	static int balance; // 공유 변수

	public static void main(String[] args) {
		while (lock == true) {
			lock = true;
			
			balance += 10; // critical section
			
			lock = false;
		}
	}
}
```

두 프로세스에서 동시에 작업한다면, 가끔 제대로 작동하지 않는다!

#### 1. 상호 배제 문제

![[Pasted image 20240227163650.png]]

- 만일 여기서 P1이 *1) while (lock == true)* 를 실행하고 나서 곧바로 *3) lock = true;* 를 실행해야 다른 프로세스가 임계구역에 들어오는 것을 막을 수 있다
- 하지만, P1이 *3) lock = true;* 를 실행하기 전에 P2가 *2) while (lock == true);* 를 실행하게 되면 둘 다 임계구역에 진입하여, 상호 배제 조건을 보장하지 않는다
- 또한, 둘 다 잠금이 풀리길 기다리려면, busy waiting을 해야한다.
(작업이 필요없다 하더라도 계속 무한 루프를 돌아야 함 == 시스템 낭비)

#### 2. 한정 대기 문제


```java 
public class Main {

	static boolean lock1 = false; // 공유 변수
	static boolean lock2 = false;
	static int balance; // 공유 변수

	public static void main(String[] args) {
	}
	
	private static void process1() {
		lock1 = true;
		while (lock2 == true) {
			balance += 10;
			
			lock1 = false;
		}
	}

	private static void process2() {
		lock2 = true;
		while (lock1 == true) {
			balance += 10;
			
			lock2 = false;
		}
	}
	
}
```

잠금을 하고 다른 프로세스가 잠겼는지 확인해서, 각 프로세스간의 상호 배제가 보장됨

하지만, 두 프로세스 모두 임계구역에 진입하지 못하는 무한 대기가 일어난다
플로우는 다음과 같음
1) P1이 lock1 = true; 실행후 CPU 시간을 다 사용. CS 이후 P2가 실행
2) P2도 lock2 = true; 실행 후 CPU 시간을 다 사용. CS 이후 P1 실행
3) 두 프로세스 모두 while (lockN == true)에 걸려 무한 루프에 빠진다

결국 둘다 while에 걸려서 무한루프에 빠져서 임계구역에서 벗어나지 못함
또한, 프로세스가 늘어날 때마다 공유 변수가 하나씩 늘어나서 비효율적임


#### 3. 피터슨 알고리즘
- 공유 변수 turn이라는 친구를 더 사용함
```java
public class Main {

	static boolean lock1 = false; // 공유 변수
	static boolean lock2 = false;
	static int turn = 1;
	static int balance; // 공유 변수

	public static void main(String[] args) {
	}
	
	private static void process1() {
		lock1 = true;
		turn = 2;
		while (lock2 == true && turn == 2) {
			balance += 10;
			
			lock1 = false;
		}
	}

	private static void process2() {
		lock2 = true;
		turn = 1;
		while (lock1 == true && turn == 1) {
			balance += 10;
			
			lock2 = false;
		}
	}
	
}
```

임계구역 해결의 세가지 조건을 모두 만족하지만, 두 개의 프로세스만 사용 가능해 확장에 불리


#### 4. 데커 알고리즘 

```java
public class Main {

	static boolean lock1 = false; // 공유 변수
	static boolean lock2 = false;
	static int turn = 1;
	
	static int balance;

	public static void main(String[] args) {
	}
	
	private static void process1() {
		lock1 = true;
		while (lock2 == true) {
			if (turn == 2) {
				lock1 = false;
				while (turn == 2) {
					lock1 = true;
				}
			}
			
			balance += 10;

			turn = 2;
			lock1 = false;
		}
	}

	private static void process2() {
		lock2 = true;
		while (lock1 == true) {
			if (turn == 1) {
				lock2 = false;
				while (turn == 1) {
					lock2 = true;
				}
			}

			balance += 10;

			turn = 1;
			lock2 = false;
		}
	}
	
}
```

이 역시, 프로세스 늘어나면 변수도 늘어나고 전체적 알고리즘이 복잡해진다

#### 5. 세마포어

임계구역에 진입하기 전에 스위치를 사용 중으로 놓고, 임계구역에 들어간다
이후 프로세스는 앞의 프로세스가 작업을 마칠 때까지 기다린다


```java

sempahore(n); // -> RS = n;

p(); // if (RS > 0) { RS -= 1; }
     // else { block(); // 대기 }

// * critical section */

v(); // rs += 1;
	 // wakeUp();

```

- *sempahore(n)* : 전역 변수 RS를 n(자원의 수)으로 초기화한다.
  RS에는 현재 사용 가능한 자원의 수가 저장된다
  
- *p()* : 잠금을 수행하는 코드
  RS가 0보다 크면 1만큼 감소시키고, RS가 0보다 작으면 0보다 커질때까지 기다린다
  
- **v()** : 잠금 해제와 동기화를 같이 수행하는 코드
  RS 값을 1 증가시키고, 세마포어에서 기다리는 프로세스에게 임계구역에 진입해도 된다는 신호를 준다

공유자원이 여러개일 때도 사용 가능함

#### 6. 모니터
- 세마포어도 문제가 있어요
	- 잘못 사용하면 임계구역이 보호받지 못해요

- 프로세스가 세마포어를 사용하지 않고 임계구역으로 들어갔을 때
- 잠금과 잠금 해제를 반대로 사용했을 때
- 잠금을 두 번 사용했을 때

여러 프로세스가 세마포어 알고리즘을 따르도록 한다면?
-> **모니터**
- 공유 자원을 내부적으로 숨기고, 공유 자원에 접근하기위한 인터페이스만 제공함

작동 원리는 다음과 같음
1. 임계구역으로 지정된 변수나 자원에 접근하고자 하는 프로세스는 직접 P()나 V()를 사용하지않고 모니터에 작업 요청을 함
2. 요청받은 작업을 모니터 큐에 저장한 후, 순서대로 처리하고 해당 프로세스에게 알려줌

-> 결국 순서대로 대기큐에 모아두고 한 곳에서 처리하자~


자바로 구현하면 이렇다고 한다

```java
monitor shard_balance {

	private int balance = 10; // 공유변수
	private boolean busy = false; // 잠금
	private condition mon; // 잠금 해제

	public void increase(int amount) {
		if (busy == true) {
			mon.wait(); // 자신의 차례가 올때까지 기다림
		}
		busy = true; 
		balance += amount;
		mon.signal(); // 다음 프로세스 콜
	}

}
```


### 심화학습

#### 파일 프로그램 코드

만일 화면에

```
Test
wax
end
```

라고 나와있을 때, 실제 이 친구는
```
{T, e, s, t, \n, w, a, x, \n, e, n, d, \0}
```
이렇게 저장되어있음

요런 한 줄로 길게 저장되는 방식이 *순차파일*
이 순차파일에 접근하는 방식이 *순차적 접근*

- `open()` 함수로 파일을 열면 파일 기술자인 *fd*를 얻는다
	- 읽기 전용, 읽기/쓰기, 쓰기 전용, 생성 등등...
- 파일 기술자는 파일 접근 권한 외에 `offset(파일 기술자 위치)` 정보도 보관한다
	- 처음 파일이 열리면 offset은 맨 앞이나, 읽기나 쓰기하면 계속 전진함

![[Pasted image 20240227193119.png]]

- 결국 모두 open(), read()/write(), close() 구조이다

#### 파일을 이용한 통신
- 부모 프로세스와 자식 프로세스가 파일 이용하여 통신하는 코드임

![[Pasted image 20240227193555.png]]

- 부모 프로세스가 자식 프로세스보다 먼저 실행되면, 자식 프로세스는 아무 작업을 하지 않아서 부모 프로세스와 자식 프로세스 사이 동기화를 해주어야 함

- 자식 프로세스를 생성하기 위한 fork() 이전에 파일을 open()시, 생성된 파일 기술자가 자식 프로세스에도 상속 됨 -> `둘 다 com.txt 파일을 rw 가능`
	- open()은 한 번이지만, close()는 자식 프로세스와 부모 프로세스 총 두 번 발생
	- 자식 프로세스에서 `"Test"` 작성시, 파일 기술자는 5번으로 이동하고, 부모 프로세스는 lseek()을 사용해 0번 위치로 이동 후 값을 읽어야 한다
		- `lseek()` : 파일 기술자를 임의로 움직이는 명령어
- 파일 이용한 통신이든, 전역 변수를 이용한 통신이든 프로세스간 동기화를 지원하지 않는다 -> wait() 해줘야함

### 파이프
- 동기화를 지원하는 단방향 통신 시스템
- 서로 관련있는 프로세스간 통신에 사용됨

![[Pasted image 20240227194230.png]]

`read()` 기술자와 `write()` 기술자가 따로 존재하여, 동기화가 가능하다
-> fd[0] : 읽기, fd[1] : 쓰기
- 양방향 구현하려면 파이프를 2개 사용해야 함
- 대기가 있는 통신이므로 wait()이 필요 없음

![[Pasted image 20240227203033.png]]

### 네트워킹
- 소켓을 이용한 네트워킹
- open(), read() / write(), close() 구조를 사용한다
- 양방향 통신과 동기화 모두 지원한다

![[Pasted image 20240227194752.png]]

- 서버는 소켓을 생성한 후, `bind()` 하여 생성한 소켓을 특정 포트에 등록한다
	- `bind()` : 서버가 동시에 여러 클라이언트에 서비스를 하기 위해 하나의 포트번호에 여러 개의 소켓을 생성하는 것
	- 여러 컴퓨터가 연결된 상황에서는 각 컴퓨터를 ip 주소로 구분하고, 한 컴퓨터에서 여러 프로세스가 접근할 경우 포트 번호를 통해 구분함
- 소켓이 정상적으로 등록되는 경우, 이후에 `listen()` 해 클라이언트를 받을 준비를 하다가, 여러 클라이언트가 동시에 connect하는 경우, 그 중 하나를 골라 작업을 시작한다
	- 이후 클라이언트가 `accept()` 되는 경우, 소켓 기술자가 생성되고 작업이 시작 됨
	- `read()`나 `write()` 작업을 마치는 경우, 생성된 소켓 기술자를 닫고, 다음 클라이언트를 기다림