
프로세스는 생성, 준비, 실행, 대기와 같은 여러 상태를 거친다.
이런 프로세스가 생성된 후, 종료될 때까지 모든 상태 변화를 조정하는 일을 하는 것이 바로 **CPU 스케줄러**다.

그렇다면 스케줄링은? 
- `여러 프로세스의 상황을 고려하여, CPU와 시스템 자원을 어떻게 배정할지 결정하는 일`이다

스케줄링은 고수준 스케줄링과 저수준 스케줄링으로 나뉨

**고수준 스케줄링**
- 시스템 내의 전체 작업(OS의 일) 수를 조절하는 것
- 1개 혹은 여러 개의 프로세스로 이루어진다
- 한 작업을 시스템이 받아들이는지, 혹은 거부하는지를 결정한다
- 이 고수준 스케줄링에 따라 시스템 내에서 동시에 실행 가능한 프로세스의 총 개수가 정해진다
- 승인 스케줄링, 작업 스케줄링, 장기 스케줄링이라고도 함

**저수준 스케줄링**
- 작은 단위의 스케줄링, 짧은 시간에 일어나 *단기 스케줄링*이라고도 부름
- 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 결정

**중간 수준 스케줄링**
- 고수준 스케줄링과 저수준 스케줄링 사이에 일어나는 스케줄링
- 고수준 스케줄링은 프로세스 활성화 여부를 결정하여 전체 프로세스의 수를 조절하는 방식이지만, 
	  프로세스 활성화 후에도 여러 사정으로 시스템에 과부하가 걸릴 수 있다.
- 중간 수준 스케줄링은 `중지(suspend)`, `활성화(active)`로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하를 막는다.

#### 스케줄링의 목적
- CPU 스케줄링의 원래 목적은 모든 프로세스가 공평하게 작업하도록 하는 것
- 즉, 특정 프로세스가 시스템 자원을 독점 혹은 파괴하는 것을 막기 위해 중요도에 따라 우선순위를 배정해야 함
- 또한, 시스템 자원을 효율적으로 배분하여 전체적인 시스템의 성능을 높여야 함
- 프로세스 개수가 증가해도 성능에 갑작스러운 변화가 없어야 함

### 스케줄링  고려사항

- **선점형 스케줄링** : 한 프로세스가 CPU를 할당받아 실행 중이더라도, 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식
	- 프로세스가 CPU를 독점할 수 없어, 대화형이나 시분할 시스템에 적합함
	- 문맥 교환의 오버헤드가 많다
	- 예 - 인터럽트 처리 : 현 실행중인 작업을 중단하고, 커널을 깨워 인터럽트를 처리하고, 완료후 원래 작업으로 돌아감
- **비선점형 스케줄링** : 한 프로세스가 CPU를 점유하면, 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식
	- CPU 스케줄러의 작업량이 적고, 문맥 교환의 오버헤드가 적다
	- 일괄 작업 방식의 스케줄러에 사용된다


#### 프로세스 우선순위
- 커널 프로세스의 우선순위가 일반 프로세스보다 높다.
	- 당연히 커널 프로세스끼리도, 일반 프로세스끼리도 우선순위가 있음
- `우선순위가 높다 == 더 빨리, 자주 실행된다`
- 일반 프로세스의 우선순위는 사용자가 조절 가능하다

#### CPU 집중 프로세스와 입출력 집중 프로세스
- 프로세스는 생성된 후 준비, 실행, 대기 상태를 거쳐 완료됨
- 프로세스가 CPU를 할당받아 실행하는 작업을 CPU 버스트, 입출력 작업을 입출력 버스트라고 함
- 위 작업 형태에 따라 CPU 집중 프로세스와 입출력 집중 프로세스로 나눌 수 있음
	- *CPU 집중 프로세스* : 수학 연산과 같이 CPU를 많이 사용하는 프로세스, 즉 CPU 버스트가 많은 프로세스
	- *입출력 집중 프로세스* : 입출력을 많이 사용하는 프로세스, 즉 입출력 버스트가 많은 프로세스
- 두 프로세스가 같이 있을 때는 입출력 집중 프로세스를 먼저 실행 상태로 옮기는 것이 효율적.(다른 프로세스가 CPU를 사용 가능)

![[Pasted image 20240222170156.png]]

- 스케줄링시 입출력 집중 프로세스의 우선순위를 CPU 집중 프로세스보다 높이면 시스템의 효율이 향상됨
- 입출력 집중 프로세스는 잠깐 CPU를 사용한 후 대기 상태로 이동하기 떄문에 다른 프로세스가 CPU를 사용할 수 있음
- 입출력 집중 프로세스가 CPU 집중 프로세스보다 실행 상태에 먼저 들어가는 경우를 사이클 훔치기라고 함

#### 전면 프로세스와 후면 프로세스
- 전면 프로세스 : GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스, 현재 입력과 출력을 사용하는 프로세스이며, 사용자와 상호작용이 가능하여 상호작용 프로세스라고도 함
- 후면 프로세스 : 사용자와 상호작용이 없는 프로세스, 일괄 작업 프로세스라고도 함

#### 스케줄링 우선순위 정리

![[Pasted image 20240222170833.png]]


### 다중 큐

- 프로세스의 중요도는 PCB에 표시됨
- CPU 스케줄러가 모든 프로세스 제어 블록을 뒤져서, 가장 높은 우선순위의 프로세스에 CPU를 매번 할당하는 것은 번거로움
- 우선순위에 따라 여러 큐를 만들면 편리함
![[Pasted image 20240222171256.png]]

- 프로세스가 준비 상태에 들어올 때마다 자신의 우선순위에 해당하는 큐의 마지막에 삽입됨
- 준비 큐를 몇 개로 나눌지, 여러 개의 준비 큐에 있는 프로세스 중 어떤 프로세스에 CPU를 할당할지는 스케줄링 알고리즘에 따라 달라짐


- 우선순위 배정 방식은 고정 우선순위 방식과 변동 우선순위 방식이 있음
	- *고정 우선순위 방식*: 운영체제가 프로세스에 우선순위를 부여하면 프로세스가 끝날 때까지 바뀌지 않는 방식
	- *변동 우선순위 방식*: 프로세스 생성 시 부여받은 우선순위가 프로세스 작업 중간에 변하는 방식. 구현은 어려우나 시스템 효율성 높일 수 있음

#### 대기 상태의 다중 큐
- 대기 상태에서도 다중 큐를 사용한다.
- 시스템의 효율을 높이기 위해, 대기 상태에서는 같은 입출력을 요구한 프로세스끼리 모아둔다

![[Pasted image 20240222171755.png]]

- 준비 상태의 다중 큐와 대기 상태의 다중 큐는 차이가 있음
- 준비 큐는 한 번에 하나의 프로세스를 꺼내어 CPU를 할당하는 반면, 대기 큐는 여러개의 프로세스 제어 블록을 동시에 꺼내어 준비 상태로 옮긴다
- 이렇게 동시에 끝나는 인터럽트를 처리하기 위해 인터럽트 벡터...를 사용
	- 인터럽트 벡터 : 완료된 입출력 정보와 처리 방법


![[Pasted image 20240222172104.png]]
CPU 스케줄러가 관리하는 프로세스 상태와 다중 큐

### 스케줄링 알고리즘
- 크게 *비선점형 알고리즘*과 *선점형 알고리즘*으로 나뉨
- 비선점형 알고리즘은 프로세스가 CPU를 할당받으면 작업이 끝날 때까지 CPU를 놓지 않기 때문에 효율이 떨어져 지금은 거의 사용되지 않음
- 선점형 알고리즘은 시분할 시스템을 고려하여 만들어진 알고리즘, 어떤 프로세스가 CPU를 받아 실행 중이더라도 운영체제가 CPU를 강제로 뺏을 수 있다

- 스케줄링 알고리즘의 평가기준은 CPU 사용률, 처리량, 대기 시간, 응답 시간 등이 있음
- CPU 알고리즘의 효율성을 평가할 때 사용률과 처리량은 계산하기 어려워서, 주로 대기 시간, 응답 시간, 반환 시간, 실행 시간을 합쳐서 나타냄

![[Pasted image 20240222173644.png]]

- 대기 시간 : 프로세스 생성 후 실행되기 전까지 대기하는 시간 
- 응답 시간 : 첫 작업을 시작한 후, 첫 출력이 나오기까지의 시간
- 실행 시간 : 프로세스 작업이 시작된 후, 종료되기까지의 시간
- 반환 시간 : 대기시간 포함, 실행 종료될 때까지의 시간


주로 평균 대기시간을 바탕으로 성능을 비교하지만, 알고리즘의 절대적인 성능 지표가 아닌, 어떻게 동작하는지 파악하는 도구로 생각하면 굳

#### FCFS(First Come First Served) 스케줄링
- FCFS 스케줄링은 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식
- 평균 대기시간으로 성능을 구할 때, 
- 콘보이 효과 : 처리 시간이 긴 프로세스가 CPU를 차지하면, 다른 프로세스들은 하염없이 기다려 효율성이 떨어짐
#### SJF 스케줄링
- 준비 큐에 있는 프로세스 중에서 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식
- 작은 작업을 먼저 시행하기 때문에 효율성이 좋아지지만, 아래와 같은 단점 존재
	- OS가 프로세스의 종료 시간을 정확히 예측하기 어려움
		- 키보드 입력과 같은 경우.. 얼마나 걸릴지 예측 불가능 함
	- 공평하지 못함
		- 아사 현상: 준비큐에 먼저 도착하지만, 종료시간이 긴 경우 계속 작업이 연기될 수 있음

#### HRN 스케줄링
- 비선점형 알고리즘으로, 최고 응답률 우선 스케줄링이라고도 함
- 서비스를 받기 위해 기다린 시간과 CPU 사용 시간을 고려한 우선순위를 기준으로 스케줄링을 함
	**우선순위 = (대기 시간 + CPU 사용 시간) / CPU 사용 시간**
- sjf 보단 낫지만.. 여전히 공평성이 위배돼 사용 잘 안함

#### 라운드 로빈 스케줄링
- 한 프로세스가 할당받은 시간 동안 작업을 하다가, 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식
- 콘베이 효과가 줄어든다

 **타임 슬라이스와 컨텍스트 스위칭**
 - RR 스케줄링과 FCFS 스케줄링의 평균 대기 시간이 같다면, 라운드 로빈이 더 비효율적임. RR같은 선점형 방식에서는 *문맥 교환이 추가되기 때문*
	 -> RR 스케줄링이 효과적으로 작동하려면, 문맥 교환에 따른 추가시간도 고려해야함
- 타임 슬라이스가 크다면
	- 하나 작업 끝나고 바로 다음 작업이 시작되는 것처럼 보이나, 반응속도 느림
- 타임 슬라이스가 작다면
	- 여러 프로세스가 동시에 실행되는 것 처럼 느껴지지만, 성능 저하
*결론 : 타임슬라이스는 되도록 작게, 컨텍스트 스위치 시간 고려해서 적당하게
다 계산한다음 알잘깔딱센*

#### SRT(Shortest Remaining Time) 우선 스케줄링
- 기본적으로 RR 스케줄링을 사용하지만,
  할당받을 프로세스를 선택할 때 남아있는 작업시간 가장 적은 프로세스 선택
- 안좋은 알고리즘!
	- 현재 실행 중인 프로세스와 큐 에 있는 프로세스의 남은 시간을 주기적으로 계산하고,  남은 시간이 더 적은 프로세스와 문맥 교환을 하는 작업이 추가됨
#### 우선순위 스케줄링
- 프로세스가 갖는 중요도에 따른 우선순위를 반영한 알고리즘
- 우선순위는 선점형 방식과 비선점형 방식 모두 구현 가능하며, 고정 우선순위와 변동 우선순위로 나뉨
	- 고정 우선순위 알고리즘 : 한번 우선순위 받으면 종료시까지 고정
	- 변동 우선순위 알고리즘 : 일정 시간마다 우선순위 변경. 시스템이 복잡하지만 시스템의 상황을 반영하여 효율적인 운영 가능
- 문제점
	- 큐 프로세스 순서를 무시하고 우선순위 기준으로 CPU를 할당해서 공평성을 위배하고 아사 현상을 일으킴
	- 우선순위 매번 바뀌어, 오버헤드가 일어나 시스템 효율성이 떨어짐
- 하지만, 프로세스 우선순위는 시스템의 효율성이 아닌, *프로세스의 중요도를 기준으로 결정* 된다

#### 다단계 큐 스케줄링
- 운영체제로부터 부여받은 우선순위에 따라 준비 큐를 여러개 사용하는 방식
- 큐는 라운드 로빈 방식으로 운영
- 우선순위가 높은 상위 큐 프로세스의 작업이 끝나기 전에는 하위 프로세스의 작업을 할 수 없어, 우선순위 낮은 프로세스 작업이 연기될 수 있음
  -> 그래서 다단계 피드백 큐 스케줄링이 나왔다

#### 다단계 피드백 큐 스케줄링
- 다단계 큐 스케줄링은, CPU를 사용하고 난 프로세스의 우선순위는 낮아짐
- CPU를 사용하고 난 프로세스는 원래 큐로 돌아가지 않고, 우선순위가 낮은 큐의 끝으로 들어감
	-> 우선순위가 낮은 프로세스의 실행이 연기되는 문제를 완화함
- 하지만, 우선순위가 낮은 프로세스가 높은 프로세스보다 CPU를 사용할 확률은 여전히 낮음
	-> 큐의 우선순위가 낮을수록 타임 슬라이스를 크게 처리해서 해결


![[Pasted image 20240222185103.png]]
오늘날 운영체제가 CPU 스케줄링을 위해 일반적으로 사용하는 방식이다!


### 인터럽트 처리

#### 인터럽트 
- **프로세스 실행 도중 예기치 않은 상황이 발생할 때**, 발생 상황을  CPU에게 알리는 것
#### 동기적 인터럽트와 비동기적 인터럽트
- 프로세스가 실행 중인 명령어로 인해 발생하는 동기적 인터럽트와, 실행중인 명령어와 무관하게 발생하는 비동기적 인터럽트로 나눌 수 있음
	- 동기적 인터럽트(== 사용자 인터럽트)
		- 프로세스 중단하기위한 ctrl  + c
		- 입출력장치 같은 주변장치의 조작에 의한 인터럽트 
	- 비동기적 인터럽트
		- 하드디스크 읽기 오류, 메모리 불량같은 하드웨어적인 인터럽트

#### 인터럽트 처리 과정
- 모든 인터럽트는 인터럽트 번호와, 그 번호에 붙어있는 함수의 쌍으로 이루어짐

	![[Pasted image 20240222190830.png]]

- 인터럽트는 한 번에 하나씩 발생하는 것이 아닌, 한 순간에 여러 개가 동시에 발생하기도 하는데, 이렇게 하나로 묶어서 처리하는 개념을 인터럽트 벡터라 함

##### 플로우
1. 인터럽트 발생시, 현재 실행중인 프로세스는 일시 정지 상태가 되며, 재시작하기 위해 현재 프로세스 관련 정보를 임시로 저장
2. 인터럽트 컨트롤러가 실행되어 인터럽트의 처리 순서를 결정. 이때, 여러 개의 인터럽트가 동시에 발생했다면 우선순위를 고려하여 중요한 인터럽트부터 처리하도록 순서를 결정
3. 먼저 처리할 인터럽트 결정시 인터럽트 벡터에 등록된 인터럽트 핸들러(처리 위해 미리 정의된 함수, 인터럽트와 1:1 매핑)가 실행 됨. 인터럽트 발생시 핸들러 함수가 실행
4. 인터럽트 벡터에 연결된 핸들러가 인터럽트 처리를 마치면 일시 정지된 프로세스가 다시 실행되거나 종료됨

#### 인터럽트와 이중 모드
- 커널 프로세스를 실행하는 커널 모드, 사용자 프로세스를 실행하는 사용자 모드가 있음

- 사용자는 시스템 호출을 사용할 수 있고, API가 준비해놓은 다양한 함수를 이용하여 시스템 자원에 접근 가능
	![[Pasted image 20240222192238.png]]

- 사용자가 커널 모드로 진입하는 경우는 두 가지가 있다
	- 시스템 호출을 사용한 경우 : 원해서 진입
	- 인터럽트를 발생시킨 경우 : 비자발적 진입. 잘못된 명령을 수행하여 동기적 인터럽트가 발생한 것이므로 프로세스가 강제 종료됨