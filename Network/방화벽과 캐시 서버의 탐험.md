

### 1. 웹 서버의 설치 장소

- 현재는 웹 서버를 설치할 때, IP 서버의 부족과 보안상의 이유로, 웹 서버에 접근하기 전에 방화벽을 거치도록 한다.
- 방화벽이 관문의 역할을 하여, 특정 서버에서 동작하는 특정 애플리케이션에 엑세스하는 패킷만 통과시키고, 그 외의 패킷을 차단하는 역할을 한다

### 2. 방화벽의 원리와 동작 

- 방화벽의 종류는 다양한 것들이 있지만, 지금은 `패킷 필터링 형`이 많이 보급되었다
#### 패킷 필터링 조건 설정
- 패킷의 흐름과 함께 필터링 조건을 한 번 살펴보자
	- 수신처 IP 주소와 송신처 IP 주소에 따라 시점과 종점을 판단한다
	- 이때, 종점을 조건으로 설정하고 조건에 해당하는 패킷만 통과시킨다
		- 시점은 어디든 상관없어서, 종점이 웹 서버의 IP 주소에 일치하는 패킷은 통과시킨다는 조건만 설정하면 된다
	- 송신처 IP 주소에 따라 시점을 지정할 수 있다면, 이것도 조건에 추가한다(조건 추가 불가능하다면 설정하지 않아도 됨)

- 결국 웹 서버가 공개 서버용 LAN에 접속되어 있다고 가정했을 때, 방화벽이 패킷을 차단하는 플로우는 다음과 같다
	- 1 ) 인터넷에서 웹 서버에 대한 액세스를 허가하지 않으면
	- 2) 웹 서버에서 인터넷의 액세스를 금지하도록 패킷을 차단한다

#### 포트 번호 사용
- 만일 지금과 같은 상태라면, 인터넷과 웹 서버를 흐르는 패킷은 모두 통과해서 위험함
	- 결국 불필요한 패킷은 전부 차단하는 것이 좋음
- 애플리케이션을 TCP 헤더나 UDP 헤더에 기록되어 있는 포트번호를 조건으로 추가함
	- 80번 포트, 443 포트 등...

#### 컨트롤 비트로 방향 판단
- 웹의 동작은 TCP 프로토콜을 사용하여 양방향으로 패킷이 흐름
	- 고로 웹 서버 -> 인터넷 패킷을 정지시키면 웹 서버에 액세스하는 동작도 정지됨
- 결국 패킷 방향이 아닌, 액세스 방향을 판단하여 정지시켜야 하는데, 이를 `TCP 헤더의 컨트롤 비트`로 확인함

- 완벽하게 차단할 수 없는 경우도 있음
	- UDP는 접속 단계 동작이 없다, DNS가 대표적인 예
	  ->  컨트롤 비트로 액세스 방향 판별 불가
	

#### 사내 LAN에서 공개 서버용 LAN으로 조건을 설정한다

- 사내 LAN <-> 인터넷, 사내 LAN <-> 공개 서버용 LAN 사이의 패킷 조건도 설정해야 한다

#### 밖에서 사내 LAN으로 액세스 할 수 없다
- 사내 LAN 액세스 금지하도록 패킷 필터링 조건 설정해야함

#### 방화벽을 통과한다
- 차단 대상에 대해서 패킷을 버리고, 버린 기록을 남긴다
	- 패킷 필터링 기능 있는 라우터를 방화벽으로 사용하는 경우, 패킷을 버린 기록을 남기는 일이 드물다. 메모리 용량 때문
- 통과된 이후에는 패킷을 중계하고 끝!
	- 특별한게 없어서,, 패킷 필터링은 `라우터의 패킷 중계 기능 중 부가 기능`이라고 생각하면 됨
  
#### 방화벽으로 막을 수 없는 공격
- 특수 패킷을 받으면 웹서버가 죽는다고 가정, 방화벽은 시점과 종점만을 판단하기에,
	패킷 중에 특수한 데이터가 포함되어있어도 신경쓰지 않고 패킷을 통과시킴 -> 패킷이 웹 서버에 도착하면 웹 서버는 다운된다
- 크게 두 개의 대처법이 있다
	- 1) 웹 서버 소프트웨어를 고쳐 다운되지 않도록 하는 것
	- 2) 패킷의 내용을 조사하여, 위험 데이터 포함시 패킷 차단하도록 장치나 소프트웨어를 방화벽과 별도로 준비하는 것

### 3. 복수 서버에 리퀘스트를 분배한 서버의 부하 분산

#### 처리 능력이 부족하면 복수 서버로 부하 분산 된다
- **분산 처리**
- 다수 사용자가 집중적으로 액세스하면, 복수의 서버를 사용하여 처리를 분담하는 방법
	- 서버 한 대당 처리량을 줄이는 것이 효과적
- 가장 단순한 방법은, DNS 서버에서 분배하는 방법
	- 라운드 로빈으로 주기 돌려서 각각 매칭시켜, 균등하게 액세스 분산 가능
- 한 서버가 고장나는 경우, DNS 서버는 웹 서버가 동작하지 않는지 확인하지 못한다
	- 웹 서버가 죽어도 상관하지 않고 IP 주소를 회답함
- 라운드 로빈도 문제가 생길 수 있음
	- CGI 등의 어플리케이션에서 페이지를 만드는 경우, 복수의 페이지에 걸쳐 대화할 수도 있음
	- 웹 서버가 변하면 대화가 끊길 수도 있다!

***CGI? : 웹 서버와 외부 프로그램 사이에서 정보를 주고받는 방법이나 규약***  정도...
참고 - 깃짱블로그 : https://engineerinsight.tistory.com/204#%E2%9C%94%20%EB%93%B1%EC%9E%A5%20%EB%B0%B0%EA%B2%BD%3A%20%EB%8F%99%EC%A0%81%EC%9D%B8%20%EC%BB%A8%ED%85%90%EC%B8%A0%EC%97%90%20%EB%8C%80%ED%95%9C%20%EC%9A%94%EA%B5%AC%C2%A0-1

#### 부하 분산 장치를 이용해 복수의 웹 서버로 분할된다
- 이 좋지 않은 상태를 피하기 위해... `부하 분산 장치(로드밸런서)`등장!
- **부하 분산 장치**
	- 부하 분산 장치를 웹 서버 대신 DNS 서버에 등록
	- 결국 클라이언트는 부하 분산 장치를 웹 서버로 인식하게 됨
	- DNS 서버로 부터 받은 요청을 로드밸런서가 여러 서버에 분배함
	그럼, 로드밸런서는 *어떤 기준으로 요청을 분배하는가?*
- 대화가 복수의 페이지에 걸쳐있는지에 따라 판단 기준이 전혀 다르다.
	- 단순한 액세스면 웹 서버의 부하 상태가 판단 근거가 됨
	- 복수 페이지에 걸쳐있을 때는 웹 서버의 부하에 관계없이 이전에 리퀘스트와 같은 웹서버에 전송해야 함
	- HTTP가 statless하기에..

- 대개 HTTP 헤더에 필드를 추가하는 것으로 이전 관계를 기억하는 방식을 사용함
- 요청 송신처 IP 주소가 같다면 같은 것으로 처리할 수도 있지만, 프록시가 있어서 그럴 수 없다~

### 4. 캐시 서버를 이용한 서버의 부하 분산

#### 캐시 서버의 이용
- 캐시 서버는 *프록시*를 사용하여 데이터를 캐시에 저장하는 서버
- 웹 서버와 클라이언트 사이에 들어가, 웹 서버에 대한 액세스 동작을 중개하는 역할을 한다

#### 캐시 서버는 갱신일로 콘텐츠를 관리한다
- 캐시 서버 역시, 로드밸런서와 마찬가지로 캐시 서버를 웹 서버 대신 DNS 서버에 등록하는 방식으로 사용한다
![[Pasted image 20240401175219 1.png]]

- 찾고자 하는 데이터가 캐시 서버에 있으면 바로 전송
	- 없다면, 바로 전송한다...!

- 캐시 서버에서 웹 서버에 요청을 보낼 때, 캐시 서버를 경유했다는 헤더 필드를 추가한다
- 헤더 필드로 `Via`를 씀 (안붙이기도 함)
- 요청받은 데이터가 캐시 서버에 있을 때, 헤더 필드로 `If-Modified-Since` 를 써, 언제 정보가 부가됐는지 추가한다
- 캐시 데이터가 없을 때, 웹 서버는 헤더에 `Via` 필드를 추가하여 사용자에게 전송한다..

#### 프록시의 원점은 포워드 프록시
- 클라이언트에도 캐시 서버를 둘 수 있음. 이를 `포워드 프록시`라고 함
- 프록시는 리퀘스트의 내용을 조사한 후 전송하여, 내용에 따라 엑세스 가능 여부를 판단 가능
- `포워드 프록시` 사용시, 브라우저에서 프록시 서버라는 항목에 포워드 프록시의 IP 주소를 설정
- 포워드 프록시는 URI 부분의 URL을 전송 대상으로 사용하게 돼, 모든 서버에서 전송할 수 있다
![[Pasted image 20240401195843 1.png]]


#### 포워드 프록시를 개량한 리버스 프록시
- 포워드 프록시 사용 중, 브라우저 설정이 잘못되면 브라우저가 잘 작동 안함
**리버스 프록시**
- 브라우저에 프록시를 사용하지 않아도 사용 가능하도록, `URI`에 쓰여있는 디렉토리 명과 전송 대상의 웹 서버를 대응시켜 요청 메시지 보낼 수 있도록 함
- 서버 캐시는 이 방식을 채용함. 리버스 프록시~

#### 트랜스페어런트 프록시
**트랜스페어런트 프록시**
- 캐시 서버에서 리퀘스트 메시지의 패킷 헤더를 조사하는 방법이 있음
- IP 헤더에 수신처 IP 주소가 기록되어 있으므로, 얘를 조사하여 엑세스 대상 확인하는 방법
- 브라우저에서 웹 서버로 리퀘스트 메시지가 흘러가는 길에 트랜스페어런트 프록시를 설치한다
	- 그리고 요청이 트랜스페어런트 프록시를 통과할 때 가로채, 웹 서버에 전송한다
	- 모든 요청이 프록시를 통하게 해야하기 때문에... 길 하나로 수렴하는 형태로 네트워크를 만들고는 함

폴로햄 테코톡 : https://youtu.be/JqCgJI-Nk88?si=Q5GkW8GdAtgJ3WpR

### 5. 콘텐츠 배포 서비스

#### 컨텐츠 배포 서비스를 이용한 부하 분산
- 캐시는 서버에 두는 경우와 클라이언트에 두는 경우, 효과가 크게 차이남

- 서버측에 캐시를 둔다면...
	- 웹 서버 부하 분산엔 도움이 돼도, 인터넷에 흐르는 트래픽을 억제할 순 없음
- 클라이언트측에 캐시를 서버를 둔다면...
	- 클라이언트의 네트워크를 운영 관리하는 사람이 소유하여 웹 서버 운영자가 케어 불가능
	-  사실 서버는 클라이언트측에 캐시 있는지도 장담 못함
- 장점만 뽑아와서, 클라이언트의 프로바이더에 웹 서버 운영자가 제어할 수 있는 캐시 서버를 둘 수도 있다
- 프로바이더와 계약해서 캐시 서버두는 것도 일이다....
	- 이거 전문으로 하는 서비스를 `컨텐츠 배포 서비스`라 함

#### 가장 가까운 캐시 서버의 관점
- 콘텐츠 배포 서비스를 사용하는 경우, 인터넷 전체에 설치된 다수의 캐시 서버 중, 클라이언트가 가장 가까운 캐시 서버를 이용하도록 하는 구조 필요

- DNS 서버에서 설정하는 방법
	- DNS 동작 방식과, 라우터 경로표를 이용한다
	- 하지만 요 방식대로라면 DNS 동작 특성상, 캐시 서버 위치를 고려할 수 없음
	- 
- 결국 캐시 서버 액세스 할 경우, 라운드 로빈이 아닌, **캐시와 클라이언트 사이의 거리를 판단하여 클라이언트에 가장 가까운 캐시 서버의 IP 주소를 회답**하도록 함!

- 클라이언트와 캐시 서버 사이의 거리는 아래와 같이 판단 가능하다
	- 1) 다수 캐시 서버에 연결된 각각의 라우터에서 경로표를 입수하여, 경로표들을 모두 서버 측의 DNS 서버 곁에 모은다
	- 2) 이 경로표를 사용하여, 각 캐시 서버의 `라우터 -> 클라이언트 측의 DNS 서버`까지의 정보를 알 수 있다
	- 3) 인터넷 내부의 경로 정보는, 프로바이더 X -> 프로바이더 Y -> 프로바이더 Z 형태로 경로가 지정돼 있어, 대략적인 거리를 알 수 있음
	- 4) 모든 라우터에 대해 이 경로를 조사하고, 가장 가까운 라우터를 찾음
	
	- 다만, 클라이언트가 클라이언트 측의 DNS 서버와 같은 장소에 있는 것은 아니라 정밀도가 높진 않다
 
#### 리피터용 서버로 액세스 대상을 분배
- HTTP 헤더의 `Location` 헤더를 이용해, redirect를 통해 캐시서버로 돌리는 방법도 있다
	- 1) 클라이언트 DNS 서버의 IP 조회
	- 2) 리다이렉트용 서버의 IP 주소 회답
	- 3) 리다이렉트 서버로 리퀘스트 메시지 전송
	- 4) 리다이렉트 응답
	- 5) 캐시 서버에 요청
	- 6) 캐시 응답

- HTTP 대화가 많아져 오버헤드가 많지만, 리다이렉트는 클라이언트가 보내는 HTTP 메시지의 송신처 IP 주소를 바탕으로 거리를 판단해, 정밀도가 높다

우리의 친한 친구, CloudFront는 DNS 방식을 사용하는 것 같다

> 2.  DNS routes the request to the CloudFront POP (edge location) that can best serve the request, typically the nearest CloudFront POP in terms of latency.

https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/HowCloudFrontWorks.html

#### 캐시 내용의 갱신 방법에서 성능의 차이가 난다

- 캐시 내용 갱신이 성능에 큰 영향을 미친다~
	- 캐싱된 내용이 맞는지 확인하려면, 갱신 확인 동작이 필요해서 시간이 더 걸릴 수 있다
	- -> 고로, 캐싱한 데이터 갱신되면 즉각 반영하세요~
- 컨텐츠 배포 서비스는 요 기능이 보통 내장돼있음

> 클라우드 프론트도 비슷한듯~
>  3. CloudFront checks its cache for the requested object. If the object is in the cache, CloudFront returns it to the user. If the object is _not_ in the cache

