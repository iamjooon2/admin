
### 1) HTTP 리퀘스트 메시지를 작성한다

#### 1. URL 입력
- 사실 `http://` 말고도 `file:`  `mailto:` 등으로 시작하는 것 등 여러가지가 있다
- 브라우저를 웹 서버에 엑세스 하는 것 말고도, 다른 용도로도 쓸 수 있기 때문
	- 파일 업로드하면 `ftp:`, 웹 서버 엑세스 시 `http:` 등의 각각의 프로토콜을 앞에 붙인다
	- 가장 뒤에는 파일의 경로

#### 2. 브라우저가 URL 해독
- 브라우저는 웹 서버에 보내는 리퀘스트의 메시지를 작성하기 위해 URL을 해독한다
- 웹 서버 기준, 아래와 같이 해독함
![[Pasted image 20240310011943.png]]

#### 3. 파일명을 생략했을 때는
- 서버에서 미리 엑세스할 파일을 설정해둔다
	- `index/html` 또는 `default.html`
- `http://www.lab.gachon.ac.kr/whatisthis` 같은 경우
	- 웹 서버에 `whatisthis` 라는 파일이 있는 경우 `whatisthis` 를 파일로 보고, 디렉토리가 있으면 디렉토리로 본다

#### 4. HTTP의 기본 개념

![[Pasted image 20240310085228.png]]
- URL을 해독하면, 어디에 엑세스해야 하는지 판명하고, 어디에 보낼지 판독한다
	- 이 목적지를 `URI`라고 한다
- 브라우저가 HTTP 프로토콜을 사용하여 웹 서버에 엑세스 함
	- 이때, 리퀘스트 메세지를 통해서 요청을 보낸다
	- 이 메시지에 메소드, URI가 포함된다
- 서버는 응답 메시지를 보낼 때
	- 스테이터스 코드를 통해 서버의 결과를 반환한다

- HTTP 메서드는 `GET`, `POST`, `HEAD`, `OPTIONS`, `PUT`, `DELETE` 등이 있다
	- GET -> 읽기 요청
	- POST -> 쓰기 요청
	- HEAD -> 읽기와 같지만, 메시지 헤더만 반송하고 데이터 내용을 돌려보내지 않음
	- OPTIONS -> 통신 옵션을 통지하거나 조사할 때 사용

#### 5. HTTP 리퀘스트 메시지를 만든다
- 리퀘스트 메시지를 만들 때, 먼저 메시지의 첫 번째 행에 있는 `리퀘스트 라인`을 쓴다
- 리퀘스트 메시지
	- 리퀘스트 라인
		- `메소드`, `URI`, `HTTP 버전` 을 가진다
		- 이 한 행으로 리퀘스트의 대략적인 내용을 알 수 있다
	- 메시지 헤더
		- 한 행당 하나의 헤더 필드를 사용한다
		- 리퀘스트의 부가적인 정보를 나타낸다
	- 메시지 본문
		- 클라이언트에서 서버에 송신하는 데이터
		- 폼 페이지에 입력한 데이터를 `POST` 로 보낼 때 데이터가 들어감
#### 6. 리퀘스트 메시지를 보내면 응답이 되돌아온다
- 응답 값은 리스폰스 메시지로 보낸다
	- 스테이터스 라인
		- `HTTP 버전`, `스테이터스 코드`, `응답 문구`를 포함한다
		- 스테이터스 코드
			- 2xx -> 정상 종료
			- 3xx -> 무언가 다른 조치가 필요함
			- 4xx -> 클라이언트 오류
			- 5xx -> 서버 오류
	- 메시지 헤더
		- 리퀘스트 메시지의 응답 헤더와 동일하다
	- 메시지 본문
		- 서버에서 클라이언트에 송신하는 데이터이다
		- 파일에서 읽은 데이터나 GCI 애플리케이션이 출력한 데이터가 들어간다
		- 본문은 바이너리 데이터로 취급한다

### 2) IP 주소를 DNS 서버에 조회한다

#### 1. IP 주소의 기본
- HTTP의 메시지를 만들면, `운영체제에게 의뢰`하여 액세스 대상의 웹 서버에게 송신한다
	- 브라우저는 URL을 해독하거나 HTTP 메시지를 만들 뿐
	- 메시지를 `네트워크에 송출하는 기능`은 `운영체제에 의뢰`한다
	- 이때, OS에 의뢰시 도메인이 아닌 IP 주소로 지정해야한다
	- -> 결국, **HTTP 메시지를 만드는 동작의 다음은 도메인명에서 IP 주소를 조사하는 동작**이 됨
- TCP / IP 구조
	![[Pasted image 20240310101824.png]]
- TCP/IP의 경우, **서브넷**이라는 작은 네트워크를 `라우터`를 통해 전체 네트워크가 만들어진다
	- 서브넷 : 허브에 몇 대의 PC가 접속된 것
	- 라우터 : 패킷을 중계하는 장치, 허브 사이를 중개 함
	- 허브 : 패킷을 중계하는 장치, 하나의 서브넷을 중개 함

- ㅇㅇ동 ㅇㅇ번지 라는 형태로 네트워크의 주소를 할당하는데
	- `동에 해당하는 번호`가 `서브넷`이고
	- 번지에 해당하는 번호가 네트워크의 주소, `호스트 번호`
	- 서브넷과 호스트 번호를 합쳐서 `IP 주소`라고 한다
- 액세스 대상의 서버까지 메시지를 운반할 시, 이 IP 주소에 따라 액세스 대상이 어딨는지 판단하고 운반한다
	- 송신측에 메시지를 보내면 서브넷 안에 있는 허브가 운반하고, 송신측에서 가장 가까운 라우터까지 도착한다
	- 라우터에 도착했다면, 라우터가 메시지 보낸 상대를 파악하고 다음 라우터로 보낸다
	- 다시 서브넷의 허브가 라우터까지 메시지를 보낸다
	
![[Pasted image 20240310104211.png]]

- IP 주소는 32비트의 디지털 데이터이다.
	- 실제로는 1바이트씩 점으로 구분하여 10진수로 표기한다
	- `넷마스크`라는 주소 정보를 IP 주소에 덧붙인다
	- 넷마스크는 IP 주소에서 32비트의 디지털 데이터이다

호스트 번호 비트가 모두 0이거나 모두 1일 때는 특별한 의미를 가짐
```
0.0.0.0 -> 서브넷 자기 자신을 가르킴
1.1.1.1 -> 서브넷 내 기기 전체에 패킷 보내는 브로드캐스트
```

#### 2. 도메인 이름과 IP 주소는 왜 구분해서 사용할까
- IP 주소같은 것은 그만 두고, 이름으로만 상대를 지정하여 통신하면 편하지 않을까?
	- IP는 4바이트분의 수치만 취급하지만, 도메인의 용량이 더 크다
	- 결국 라우터에 부하가 더 가기때문에.. 데이터 운반하는 동작에 더 많은 시간이걸리면서 네트워크 속도가 느려진다~!

- 결국 DNS 등장!

#### 3. 소켓 라이브러리가 IP 주소를 찾는 기능을 제공한다
- 브라우저에 www.google.com 치면, DNS 서버에 조회하게 되는데.. 이 조회를 한번 알아보자
- DNS 서버에 조회한다는 것은, `조회 후 반송되는 응답메시지를 받는다는 것`
- DNS 서버에 대해 클라이언트로 동작한다고도 할 수 있는데,
	- `DNS 리졸버`, `리졸버` 라고도 부른다
- DNS의 원리를 사용하여 IP 주소를 조사하는 것을 네임 리졸루션이라고 한다
	- 이를 실행하는 것이 리졸버이다

- 이 리졸버의 실체는 Socket 라이브러리에 들어있는 부품화한 프로그램이다

#### 4. 리졸버를 이용하여 DNS 서버를 조회한다
- 소켓 라이브러리에 들어있는 프로그램은 부품화되어 있고, 애플리케이션에서 간단히 호출하여 이용할 수 있다
- 리졸버 호출 시..
	- 리졸버가 DNS 서버에 조회 메시지를 보내고, DNS 서버에서 응답 메시지가 돌아온다
	- 응답 메시지 속에 IP 주소가 포함되어 있어, 리졸버는 이놈을 추출하여 브라우저에서 지정한 메모리 영역에 써 넣는다
	- 브라우저는 이 메모리 영역에서 IP 주소를 추출하여 Http 리퀘스트 요청과 함께 OS에 건네주어 송신을 의뢰한다

#### 5. 리졸버 내부의 작동
- 1 - 브라우저가 리졸버를 호출하면, 제어권이 리졸버 내부로 넘어간다
- 2 - 애플리케이션의 동작이 일시적으로 정지된다
- 3 - 리졸버가 브라우저에서 의뢰받은 작업을 실행한다
	- 브라우저가 HTTP Request Message를 만드는 작업과 유사하다
	- `해당 이름을 가진 서버의 IP를 가르쳐 주세요~`를 만듬
- 4 - 송신은 리졸버가 스스로 실행하는 것이 아닌, **OS 내부의 프로토콜 스택을 호출**하여 실행을 의뢰한다
- 5 - LAN 어댑터를 통해 메시지가 DNS 서버를 향해 송신된다
- 6 - 엑세스 대상의 웹 서버가 DNS 서버에 등록되어 있으면, 답을 응답 메시지에 써서 클라이언트에 반송한다
- 7 - 메시지는 네트워크를 통해 클라이언트에 도착한 후 프로토콜 스택을 경유하여 리졸버에 건네진다
- 8 - 리졸버가 내용을 해독하여 IP 주소를 추출한 후, 애플리케이션에 IP 주소를 건네준다

### 3) 전 세계의 DNS 서버가 연대한다

#### 1. DNS 서버의 기본 동작
- DNS 서버는 클라이언트에서 조회 메시지를 받고, 조회의 내용에 응답하는 형태로 정답을 회답한다
- 조회 메시지가 갖고 있는 정보는 다음과 같다
	- 이름 - 서버나 메일 배송 목적지와 같은 이름이다
	- 클래스 - DNS의 주소를 고안했을 때 네트워크 이외의 이용도 고려했으나 현재는 인터넷만 사용. 현재는 항상 인터넷만을 사용하는 `IN` 값이 됨
	- 타입 - 이름에 어떤 타입(종류)의 정보가 지원되는지를 나타낸다

![[Pasted image 20240310141916.png]]

- DNS 서버는 등록된 정보를 찾아서 이름, 클래스, 타입의 세 가지가 일치하는 것을 찾는다

#### 2. 도메인의 계층
- 정보를 분산시켜 다수의 DNS 서버에 등록하고, 다수의 DNS 서버가 연대하여 어디에 정보가 등록되어 있는지를 찾아내는 구조
- DNS 서버가 연대하여, 어디에 정보가 등록되어 있는지를 찾아내는 구조이다

- DNS 서버에 등록된 정보는 모두 **도메인** 이라는 계층적 구조를 가진 이름이 붙어있다
- techcourse.woowahan.com 이라면....
	- com 아래 woowahan, woowahan 아래 techcourse의 구조
	- 한 대의 DNS 서버에 도메인 한 대를 등록하는 걸로 가정했을 때...
	- 도메인의 계층 구조와 같은 형태로 DNS 서버가 배치된다

#### 3. 담당 DNS 서버를 찾아 IP 주소를 가져온다
- DNS 서버에 등록한 정보를  찾아낼 때, 액세스 대상의 웹 서버가 어느 DNS 서버에 등록되어 있는지를 찾아낸다
- 하위 도메인을 담당하는 DNS 서버의 IP 주소를, 그 상위의 DNS 서버에 등록한다
- 그리고 상위 서버의 도메인을 또 그 상위의 DNS 서버에 등록하는 식으로 차례대로 등록한다
	- `lab.glass.com` 이라는 도메인을 담당하는 DNS 서버를 `glass.com` DNS 서버에 등록하는 방식
	- 맨 끝의 com을 최상위 도메인이라고 한다
	- 이 최상위 도메인 위에 또 하나의 루트 도메인이 있음
	- 루트 도메인의 DNS 서버를 인터넷에 존재하는 DNS 서,버에 전부 등록하는 것

- 이제 등록이 다 된 DNS 서버는, 수만 대 이상 있는 DNS 서버 중에서 원하는 DNS 서버를 찾아낼 수 있다


![[Pasted image 20240310133307.png]]

플로우는 다음과 같다

1. 사용자가 `www.lab.glasscom.com` 이라는 웹 서버에 관한 정보를 조회하기로 맘먹는다
	1)  가장 가까운 DNS 서버에는 `www.lab.glasscom.com` 이라는 이름이 등록되어 있지 않아, 도메인의 계층을 위로부터 차례로 따라간다
2.  가장 가까운 DNS 서버는 com 도메인의 DNS 서버에 조회 메시지를 보낸다
3. `www.lab.glasscom.com` 은 여기서도 등록되어 있지 않으므로 여기서 설명한 것처럼 com의 아래이 있는 `glass.com` 도메인의 DNS 서버의 IP 주소를 반송한다
4. 이와 같이 위에서 아래로 DNS 서버를 따라가는 동작을 반복하면, 이 중에서 원하는 DNS 서버에 도달하게 된다
5. 이후 조회에 대한 답이 돌아올 때, `www.lab.glasscom.com`의 주소를 알 수 있다
6. 조회 메시지를 받은 DNS 서버는 이렇게 해서 IP 주소를 조사하고, 이것을 클라이언트에 회답한다
7. 클라이언트는 웹 서버의 IP 주소를 알고 여기에 액세스 할 수 있다

#### 4. DNS 서버는 캐시 기능으로 빠르게 회답할 수 있다
- 현실의 인터넷에서는 한 대의 DNS 서버에 복수 도메인의 정보를 등록할 수 있으므로, 한 도메인에 한 대씩 DNS 서버가 존재한다고 단정할 수 없다
- 상위와 하위의 도메인을 같은 DNS 서버에 등록하는 경우도 있다
	- 이 경우 상위의 DNS 서버에 조회하면 하위 DNS 서버를 하나 건너뛰고, 다시 그 아래의 DNS 서버에 관한 정보가 돌아옵니다
- **캐시** 덕에 취상위 루트 도메인에서 차례대로 따라간다는 원칙대로 움직이지 않을 수도 있고, 한 번 조사한 이름을 캐시에 기록할 수도 있다, 존재하지 않는 경우에도 보존할 수 있다
- DNS는 한 번 조사한 이름을 `캐시에 기록할 수 있음`

- 캐시에 저장된 이후 등록 정보가 변경될 수도 있기 때문에 올바르다고 단언할 수 없음 주의하세용


### 4) 프로토콜 스택에 메시지 송신을 의뢰한다

#### 1. 데이터 송-수신 동작의 개요
- 데이터를 전송하는 일은 유저 영역이 아닌 커널 영역.. 고래서 운영체제에 운영해야 함
- IP 주소를 조사 후 IP 주소의 상대, 액세스 대상 웹 서버에 메시지를 송신하도록 내부에 있는 **프로토콜 스택**에 의뢰한다
	- 이때, DNS 서버에 IP 주소를 조회할 때와 같이 Socket 라이브러리에 들어있는 프로그램 부품을 이용한다
- HTTP 메시지가 디지털이므로, 곧 디지털 데이터를 송수신한다고 생각해도 된다
- 소켓 라이브러리를 이용한 데이터 송-수신 동작의 이미지는 그림으로 나타내면 다음과 같다
![[Pasted image 20240310155535.png]]
- 소켓은 결국, `미리 연결을 만들어두는 것` `어느 쪽에서 쏟아부어도 상관 없고 양방향으로 데이터를 흘릴 수 있는 것`
- 송수신 전에 양자 사이를 파이프로 연결하는 동작이 꼭 필요하다!

- 데이터 양 끝의 출입구를 **소켓**이라 함
- 소켓 연결 플로우는 다음과 같다
	1. 서버측이 먼저 파이프를 연다
	2. 클라이언트가 파이프를 열고, 서버에 연결한다
	3. 데이터를 서로 송수신한다
	4. 파이프를 분리하고 소켓을 말소한다
- 이 네 가지 동작을 실행하는 것은 OS 내부의 프로토콜 스택
- 브라우저 등의 애플리케이션은 자체에서 파이프를 연결하거나 거기에 데이터를 쏟아붓지 않고, 프로토콜 스택에 의뢰해서 파이프를 연결하거나 데이터를 쏟아붓는다
#### 2. 소켓의 작성 단계

![[Pasted image 20240310163659.png]]

- 전지적 브라우저 시점
	- DNS 서버에 조회를 보낼 때와 같이 소켓 라이브러리의 부품을 호출한다
	- 소켓 내부에 제어가 넘어가서 소켓을 만드는 동작을 실행하고, 이것이 끝나면 애플리케이션에 제어가 돌아온다
	- 소켓이 생기면 디스크립터(소켓을 식별하기 위해 사용하는 것)가 돌아와서, 애플리케이션은 받아 메모리에 기록해둔다
	- 디스크립터는 소켓을 식별하기 위해 사용하는 것
``애플리케이션은 디스크립터라는 번호표 같은 것, 소켓을 식별함``

- 소켓이 생기면 디스크립터라는 것이 생기는데, 애플리케이션은 이걸 받아 메모리에 기록
- 복수의 소켓이 하나의 컴퓨터에 쓰이기도 함

#### 3. 파이프를 연결하는 접속 단계
- 만든 소켓을 서버측의 소켓에 접속하도록 프로토콜 스택에 의뢰한다
	- 요점은 `디스크립터`, `서버의 IP 주소`, `포트 번호`
	- 디스크립터
		- 여기에서 지정한 디스크립터는 connect가 프로토콜 스택에 통지
		- 프로토콜 스택이 통지받은 디스크립터를 보고 어느 소켓을 서버측에 접속할지 판단하여 동작을 실행
	- IP 주소
		- DNS 서버에 조회하여 조사한 액세스 대상 서버의 IP 주소
		- 어느 컴퓨터에 접속할 지
	-  포트 번호
		- 어느 컴퓨터의 어느 소켓과 접속할지를 지정 가능
		- 임의로 정의해둔 규약 값임 - 웰노운 포트
		- 접속 상대측에서 소켓을 식별하기 위해 사용
`디스크립터 : 애플리케이션이 소켓을 식별`
`IP 주소와 포트번호 : 클라이언트와 서버 간의 소켓을 식별하는 것`

#### 4. 메시지를 주고받는 송수신 단계
- 소켓이 상대측과 연결되면, 데이터를 쏟아 상대측의 소켓에 데이터가 도착한다
- 도착하면 그것이 메시지 송신
	- 수신한 응답 메시지를 저장하기 위한 메모리 영역을 **수신 버퍼**라고 한다
	- 응답 메시지가 돌아올 때 read가 받아서 수신 버퍼에 저장한다
	- 수신 버퍼는 애플리케이션 프로그램 내부에 마련된 메모리 영역이므로 수신 버퍼에 메시지를 저장한 시점에서 메시지를 애플리케이션에 건네준다

#### 5. 연결 끊기 단계에서 송수신이 종료된다

- 데이터를 보내는 작업이 끝나면 close를 호출한다
- 그 경우 파이프가 분리되고, 소켓도 말소된다
- 널널한 개발자 아저씨 : 소켓은 파일이다
	- 소켓 함수도 파일 디스크립터를 반환한다 -> 소켓은 파일이다?

- 브라우저가 데이터 수신을 완료하면 송-수신 동작은 끝나고, 이후 Socket 라이브러리의 `close`라는 프로그램 부품을 호출, 연결 끊기 단계로 들어간다
- 이때 동작은 다음과 같다(HTTP 기준)
	- 웹 서버 측에서 `close()`를 호출하여 연결을 끊음
	- 클라이언트 측에 전달되어, 클라이언트의 소켓을 연결 끊기 단계로 들어감
	- 브라우저가 수신 동작 의뢰시, 연결 끊었다는 사실 통지하면
	- 브라우저도 연결 끊김을 알고 `close()` 호출


https://stackoverflow.com/questions/11129212/tcp-can-two-different-sockets-share-a-port