
OS에 내장된 프로토콜 스택이 어떻게 송신하는지에 관해 가즈아

### 1. 소켓을 작성한다
#### 1) 프로토콜 스택의 내부 구성

- 어플리케이션의 의뢰를 받은 프로토콜 스택이, TCP 프로토콜을 이용하여 메시지를 송신하는 과정을 살펴보자

- 프로토콜 스택의 내부는 아래 그림과 같이 역할이 서로 다른 몇 부분으로 나누어져 있다
![[Pasted image 20240318091902.png]]

- 가장 위에 있는 것은 네트워크 **어플리케이션**
	- 브라우저, 메일러, 웹 서버등의 프로그램이 여기 속한다
- 어플리케이션 아랫부분에는 **Socket 라이브러리**가 있다
	- 리졸버가 내부되어있어, DNS 서버에 IP를 조회요청함
- 소켓 아래에는 **OS**가 있으며, 여기 *프로토콜 스택*이 있다
	- TCP 프로토콜을 이용하는 부분과, UDP 프로토콜을 사용하여 송수신을 담당하는 부분으로 나누어진다
```
브라우저나 메일 등의 일반적인 애플리케이션이 데이터를 송-수신 할 때는 TCP
DNS 서버에 대한 조회 등에서 짧은 제어용 데이터를 송-수신시 UDP
```

- IP 아래에 있는 LAN 드라이버는 LAN 어댑터의 하드웨어를 제어하고, LAN 어댑터가 실제 송-수신 동작을 수행한다

#### 2) 소켓의 실체는 통신 제어용 제어 정보
- 프로토콜 스택은 소켓에 기록된 제어 정보를 참조하면서 움직인다
	- 제어 정보엔 통신 상대의 IP 주소, 포트 번호, 통신 동작의 진행 상태.. 등이 있다

#### 3) 소켓 호출시의 동작
- 브라우저가 소켓 라이브러리의 프로그램 부품을 호출했을 때, 프로토콜 스택의 내부가 어떻게 움직이는지 보자
![[Pasted image 20240318103945.png]]

- 프로토콜 스택은, 소켓 한 개 분량의 메모리 영역을 확보한다
	- 초기에는 송-수신 동작이 시작되지 않아서, 초기 상태임을 나타내는 제어 정보를 소켓의 메모리 영역에 기록한다
- 이후 디스크립터를 애플리케이션에 알려준다
- 디스크립터를 받은 애플리케이션은, 이후 프로토콜 스택에 데이터 송-수신 동작을 의뢰할 때 디스크립터를 통지한다
	- 디스크립터가 나타내는 소켓이 필요한 정보를 모두 프로토콜 스택에서 알 수 있다

### 2. 서버에 접속한다

#### 1) 접속이란.....

- 이더넷이나 통신 회선은 항상 케이블과 연결되어있으므로, 언제나 신호를 보낼 수 있다
- 하지만, 소켓 만든 직후에 어플리케이션에서 데이터 송신 의뢰가 온다면?
	- 소켓을 생성하고 난 이후에는, 기록된게 없어서 통신 상대가 누구인지도 모른다
	- IP 주소나 포트 번호를 프로토콜 스택에 알리는 동작이 필요한데, 이것이 접속 동작의 한 가지 역할임
- 클라이언트에 통신 동작의 개시를 전달해야, 데이터를 송-수신 할 수 있는 상태가 된다

- *결국 접속 == 준비라는 뜻인듯*

#### 2) 맨 앞부분에 제어 정보를 기록한 헤더를 배치

- 통신 동작에 이용하는 제어 정보는 두 가지 종류가 있다
	- 헤더에 기입되는 정보
		- 클라이언트와 서버가 연락을 절충하기 위해 주고받는 제어 정보를, 패킷의 맨 앞부분인 헤더에 심어 서로 주고받는다
	- 소켓에 기록되는 정보
		- 애플리케이션에서 통지된 정보, 통신 상대로부터 받은 정보, 송-수신 동작의 진행 상황 등이 기록됨
		- 상대 측에서 볼 수 없다, 규칙에 따라 헤더의 제어정보로 기록하여 통신하면 끝이기 때문

#### 3) 접속 동작의 실체
- TCP 담당 부분에서 접속을 나타내는 제어 정보를 기록하는 TCP 헤더를 만들며 접속 시작
- 결국 소켓 라이브러리의 `connect()`를 호출한다

```
connect(<디스크립터>, <서버측 IP 주소와 포트 번호>, ....)
```

- ip 주소 포트번호를 쓰면, 프로토콜 스택의 tcp 담당 부분에 전달된다.
- tcp 담당부분은, 서버의 tcp 담당 부분과 제어 정보를 주고받는다.

**접속 프로세스**

1 - TCP 담당 부분은 데이터 송-수신 동작의 시작을 나타내는 제어정보를 기록한 TCP 헤더를 만든다
- TCP 헤더의 송신처와 수신처의 포트번호로 접속하는 소켓을 지정함
2 - TCP 헤더를 만든 이후, IP를 담당하는 곳에 건내어 송신하도록 의뢰한다
3 - IP 담당 부분이 패킷 송신 동작을 실행한다
4 - 클라이언트에서 출발한 패킷이 네트워크를 통해 서버에 도착
5 - 서버의 IP 담당부분이 TCP 담당 부분에 패킷을 건네준다
6 - 서버측의 TCP 담당 부분이 헤더에 있는 `수신처 포트번호 소켓`을 찾는다
7 - 서버의 해당 소켓이 발견되면, 이 소켓에 필요한 정보를 기록하고, 접속 동작이 진행중인 상태가 된다
8 - 서버의 TCP 담당부분이 응답을 반환
	8 - 1)  서버는 포트 번호나 SYN 비트 등을 설정한 TCP 헤더를 만든다
	8 - 2)  ACK 컨트롤 비트를 1로 만든다 (패킷 수신을 알리기 위한 동작)
	8 - 3)  TCP 헤더를 IP 담당 부분에 건네 클라이언트에 반송 의뢰
9 - 패킷은 IP 담당 부분을 경유하여, TCP 담당 부분에 도착
	9 - 1) TCP 헤더를 조사하여 서버측의 접속 동작이 성공했는지 확인
		성공 응답의 의미 : SYN이 1!
10 - 클라이언트는 패킷이 도착한 것을 서버에 알리기 위해 ACK 비트를 1로 만든 TCP 헤더를 반송

11 - 소켓이 연결 (데이터 송수신 가능한 상태) 됨!
	
	

### 3. 데이터를 송-수신한다

#### 1) 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다

- 어플리케이션이 `write()`을 호출하여, 송신 데이터가 프로토콜 스택에 건네지게 되면, 어플리케이션에 제어가 되돌아온 후
- 프로토콜 스택이 송신 동작을 실행한다

제어권이 되돌아오고, 송신 동작 실행 전까지의 과정을 살펴보면
- 프로토콜 스택이 데이터를 내부 송신용 버퍼 메모리 영역에 저장하고, 애플리케이션이 다음 데이터를 받기를 기다린다
- 데이터 길이는, 애플리케이션의 종류나 만드는 방법에 따라 결정된다
	- 두 가지 요소가 있는데, ***패킷에 저장되는 데이터의 크기***와 ***타이밍***이다

데이터의 길이 기준은 아래와 같다
- `MTU : 패킷 하나로 운반할 수 있는 디지털 데이터의 최대 길이`
- `MSS : 헤더를 제외하고 한 개의 패킷으로 운반할 수 있는 TCP 데이터의 최대 길이`

타이밍 기준은 아래와 같다
- 애플리케이션 송신 속도가 느려질 때, MSS에 가깝게 데이터를 저장하면 시간이 걸려 송신 동작이 지연된다
- 고로 (고랭 최고!) 프로토콜 스택은 내부 타이머로 일정 시간 경과하면 바로 패킷을 송신함

둘은 상보적인 관점을 중시한다
- `네트워크 효율 <-> 네트워크 지연 방지`


#### 2) 데이터가 클 때는 분할하여 보낸다
- 송신 버퍼에 저장된 데이터가 MSS의 길이를 초과했을 때, 이를 분할하는데
- MSS에 맞게 분할하고, 분할한 조각을 한 개씩 패킷에 넣어 차례대로 송신한다

![[Pasted image 20240318155641.png]]
- 데이터 조각 송신시 맨 앞 부분에 TCP 헤더를 부가한 후, IP 담당 부분에 건네주어 송신 동작을 실행한다

#### 3) ACK 번호를 사용하여 패킷이 도착했는지 확인한다
- TCP에는 송신한 패킷이 상대에게 잘 도착했는지 확인하고, 결과에 따라 다시 송신하도록 하는 기능이 있다
	- `시퀀스 번호`와 `ACK 번호`로 도착 확인 가능
		- 시퀀스 번호 : 데이터 조각 송신시, 세어둔 값을 TCP 헤더에 기록해둔 것
		- ACK 번호 : 이전 수신한 데이터의 바이트 값을 합쳐, 몇번째 바이트까지 수신한 것인지 계산하여 헤더에 기록한 것
			- 패킷 누락 여부를 확인 가능
			- 수신 측에서 ACK 번호를 되돌려 주는 동작으로 응답하는 것을 수신 확인 응답이라 함

![[Pasted image 20240318165709.png]]

다음과 같이 동작한다
- 접속 동작 개념
	- 1 - 클라이언트에서 서버에 보내는 시퀀스 번호의 초기 값(난수)을 산출해 서버에 통지한다
	- 2 - 서버는 초기값으로부터 ACK 번호, 서버의 시퀀스 번호를 산출하여 클라이언트에 통지한다
	  ***시퀀스  번호 초기값은 클/서 각각의 초기값(난수)를 보내줌***
	- 3 - 클라이언트는 받은 ACK 데이터를 산출하여 서버에 통지
- 송-수신 동작 개념
	- 4 - 클라이언트에서 초기값으로부터 시퀀스번호와 데이터를 함께 서버에 전송
	- 5 - 서버는 수신한 데이터에서 ACK 번호를 반송
	- 6, 7 - 서버에서 먼저 보내는 경우 이 반대가 된다
`시퀀스 번호와 Ack 번호로 패킷이 수신측에 도착한 것을 확인함`

#### 4) 패킷 평균 왕복 시간을 통해 ACK 번호의 대기 시간을 조정한다

- *타임아웃 값*이란
	- ACK 번호가 돌아오는 것을 기다리는 시간
- 네트워크가 혼잡하여 정체가 일어나면 ACK 번호가 돌아오는 것이 지연되므로, 이를 예측하여 대기 시간을 어느정도 길게 설정해야 한다
- 소모적인 다시 보내기는 낭비로만 끝나지 않으며, 반송이 지연되기로 한 사태는 혼잡이 원인인 경우가 많다

- TCP는 대기시간을 동적으로 변경하는 방법을 사용 중
	- ACK 번호가 돌아오는 시간을 기준으로 대기 시간을 판단한다
	- 데이터 송신 동작을 실행하고 있을 때, 항상 ACK 번호가 돌아오는 시간을 기록해두고, 돌아오는 시간이 지연되면 이것에 대응하여 대기 시간도 늘린다

#### 5) 윈도우 제어 방식을 통해 효율적으로 ACK 번호를 관리한다
- 패킷 보내고 ACK 번호 기다리는 방법이 직관적이지만, 그 시간동안 아무것도 안하면 낭비가 심하므로, **윈도우 제어 방식**을 사용한다
![[Pasted image 20240318171802.png]]

윈도우 제어 방식의 플로우는 다음과 같다
- ACK 번호 기다리는 사이, 다음 데이터 송신
- 수신 측에서 수신 버퍼에 데이터를 받는다
- 수신 측에서는 송신 측에 수신 가능한 데이터 양을 응답한다
	- 수신 측 버퍼의 오버플로우 방지 위함
- 수신 처리 끝난 후 수신 버퍼에 빈 부분 생기면, TCP 헤더의 **윈도우 필드** 를 통해서 이를 송신측에 알려준다
- 수신 가능한 데이터 양의 최대값을 **윈도우 사이즈** 라고 함(TCP를 정밀 조절하는 매개변수 중 하나)

#### 6) ACK 번호와 윈도우를 합승한다

윈도우 통지와 ACK 번호 통지 타이밍은 아래와 같이 다르다
##### 윈도우 통지 타이밍
- 수신측에서 애플리케이션에 데이터를 건네주고 수신 버퍼의 빈 영역이 늘어났을 때, 송신측에 통지
##### ACK 번호 통지 타이밍
- 수신측에서 데이터를 받았을 때, 내용 조사 후 정상 수신을 확인할 수 있는 경우
  -> 데이터 수신 후 바로!

개념 그대로 보내면, 각각의 패킷이 따로따로 송신측에 보내지게 돼 낭비가 이씀...
결국 효율성을 위해 둘을 하나의 패킷에 합승시켜 통지하게 된답니다~

#### 7) HTTP 응답 메시지를 수신한다
- 리퀘스트 메시지를 보내고, 브라우저가 Reponse를 받는 과정은 다음과 같다
	- 1 ) 브라우저가 Request 메시지 송신
	- 2) 브라우저가 응답 메시지를 받기 위해 `read()` 프로그램을 호출
	- 3) `read()` 이후 프로토콜 스택에 제어가 넘어간다
	- 4) 프로토콜 스택이 HTTP Response 응답이 오기까지 대기한다
	- 5) 프로토콜 스택이 수신 버퍼에서 응답 데이터를 추출하여 어플리케이션에 전달

### 4. 서버에서 연결을 끊어 소켓을 말소한다
#### 1) 데이터 보내기를 완료했을 때 연결을 끊는다

데이터 송-수신이 완료된 후 프로토콜 스택의 움직임을 알아보자

- 데이터 송수신 종료의 기준은, 어플리케이션이 송신해야하는 데이터를 송신 완료했다고 판단했을 때
	- 송수신 끝나는 기준은 어플리케이션에 따라서 다름
	- 프로토콜 스택은 어느 쪽에서 먼저 연결 끊어도 가능하도록 만들어짐
	
![[Pasted image 20240318175201.png]]
서버에서 연결 끊기를 한다 가정
- 1) 서버 어플리케이션이 소켓 라이브러리의 `close()`를 호출한다
- 2) 서버측의 프로토콜 스택이 TCP 헤더를 만든 후, 연결 끊기를 나타내는 정보(FIN 비트 1)를 설정한다
- 3) 소켓에 연결 끊기 동작에 들어갔다는 정보를 기록한다

클라이언트는 다음과 같은 동작을 한다
- 1) 서버에서 연결 끊기를 나타내는 정보를 담은 헤더가 도착함을 확인
- 2) 클라이언트 스택은 소켓에 서버측이 연결 끊기 동작에 들어갔다는 것을 기록한다
- 3) 패킷 수신을 사실을 알리기 위해 ACK 번호를 서버에 반송
- 4) 서버에서 ACK 번호가 돌아오면 대화 끝!
#### 2) 소켓을 말소한다
- 연결 끝나면 오작동 막기 위해 잠시 기다렸다가 소켓을 말소시킨다

1 - 클라이언트가 FIN 송신
2 - 서버가 ACK 송신
3 - 서버가 FIN 송신
4 - 클라이언트가 ACK 번호 송신


#### **3) 데이터 송수신 동작을 정리한다**

TCP 기반의 데이터 송수신 동작을 정리해보아요

![[Pasted image 20240318175730.png]]

0. 소켓 작성!
   
- 접속 동작
1. 클라이언트가 SYN을 1로 만든 TCP 헤더를 만들어 서버에 보낸다(윈도우 포함)
2. 서버에서 SYN을 1로 만든 TCP 헤더가 클라이언트로 돌아온다
3. 클라이언트에 도착하면 TCP 헤더가 받은 것을 나타내는 ACK 번호를 기록한 TCP 헤더를 서버로 보낸다

- 데이터 송수신 단계
4. 클라이언트가 송수신 메시지를 서버에 보낼 때, TCP는 적당한 크기의 조각으로 분할하고 TCP 헤더를 맨 앞에 부가하여 서버에 보낸다
5. 이 정보가 서버에 도착하면, 서버는 ACK 번호를 클라이언트에 반송한다
6. 서버가 먼저 보내면
7. 이거의 반대

- 연결 끊기 단계
8. 서버에서 클라이언트로 FIN : 1로 설정한 TCP 헤더를 보낸다
9. 클라이언트는 받았음을 의미하는 ACK 번호의 TCP 헤더를 흘려준다
10. 클라이언트는 서버에게 FIN : 1로 설정한 TCP 헤더를 보내고
11. 서버 역시 받았음을 나타내는 ACK 번호의 TCP 헤더를 흘려줌

소켓 말소!

### 5. IP와 이더넷의 패킷 송수신 동작

IP 담당 부분이 패킷을 어떻게 상대에게 송신하는지 알아봐용

#### 1) 패킷의 기본
- 패킷은 `헤더`와 `데이터`로 구분된다
	- 헤더 : 수신처를 나타내는 주소 등의 제어 정보(택배 전표 바이브)
	- 데이터 : 전달할 데이터(화물 바이브)
 ![[Pasted image 20240318182144.png]]

- 서브넷은, 라우터와 허브라는 두 종류의 패킷 중계 장치에서 아래와 같은 역할을 한다
	- 라우터가 목적지를 확인한 후, 다음 라우터를 확인한다
		  (IP가 목적지를 확인하여 다음 IP의 중계 장치를 나타낸다)
	- 허브는 서브넷 안에서 패킷을 운반하여 다음 라우터에 도착한다
		 (서브넷 안에 있는 이더넷이 중계장치의 패킷을  운반한다)

![[Pasted image 20240318182546.png]]


- MAC 헤더와 IP 헤더는 각각 역할이 아래와 같이 다른데, 각각 아래와 같은 역할을 한다
	- MAC 헤더: 이더넷용 헤더
	- IP 헤더 : IP용 헤더 

패킷 운반 플로우는 아래와 같다
- 1. 송신처에서 목적지 서버의 IP 주소를 수신처에 기록해둔다
	- IP는 수신처의 방향을 조사하고, 그 방향의 다음 라우터를 조사한다
	- 해당 라우터는 이더넷 주소를 조사하고 MAC 헤더에 기록한다
- 2. 패킷은 허브에 도착한다
	- 허브에서 표와 수신처 정보를 이용해 패킷의 목적지를 판단하고 중계한다
	- 만약 복수개의 허브라면, 순차적으로 경유한다
- 3. 패킷이 라우터에 도착한다
	- 표와 수신처 정보를 결합하여 다음 라우터를 결정한다
	- 다음 라우터의 MAC 주소를 조사한 다음 새로운 MAC 헤더에 기록한다(수신했을 때의 MAC 헤더는 버리고 새로운 MAC 헤더를 만들고 기록한다)
	- 패킷을 다음 라우터에 송신한다
- 4. 이 과정들을 반복, 목적지에 도착한다

#### 2) 패킷 송수신 동작의 개요

- 패킷 송수신 과정
	- TCP 담당 부분이 IP 담당하는 부분에 패킷 송신을 의뢰한다
	- TCP 헤더 + 데이터 조각을 IP 담당 부분에 전달한다
- IP 담당 부분은 내용물의 한 덩어리를 디지털 데이터로 간주한다
	- 제어 정보를 기록한 헤더(IP 헤더, MAC 헤더)를 부가한다
- 패킷을 네트워크용 하드웨어(무선 LAN 혹은 이더넷)에 전달한다
	- `0`이나 `1`의 비트가 이어진 디지털 데이터 형태의 패킷
- 수신처에서 회답한다

#### 3) 수신처 IP를 기록한 IP 헤더를 만든다
IP 담당 부분은 TCP 담당 부분에서 패킷 송-수신 의뢰를 받으면, `IP 헤더`를 만들어 TCP 헤더의 앞에 붙인다
이 IP 헤더에는 수신처 IP와 송신처 IP 주소가 포함돼있다

**수신처 IP 주소**
- IP는 스스로 수신처를 판단하지 않고, 어플리케이션이 지정한 상대에게 송신한다. 즉 어플리케션에 책임이 있다 간주한다
**송신처 IP 주소**
- IP 주소는 컴퓨터에 할당되는 것이 아니라, LAN 어댑터에 할당된다
- 여러 개의 LAN 어댑터에 장착시 서로 다른 IP 주소가 할당 됨
- 이 경우, 어느 IP 주소를 설정해야할지 판단하는데... 어느 LAN 어댑터를 사용해서 패킷을 결정할지 판단하는 것과 같다
**경로표**
- 수신처 IP 왼쪽 부분과 라우팅 테이블의 Network Destination 항목을 비교한다
- 네트워크 인터페이스(==랜카드?) 에서 패킷을 송신하면 상대에게 패킷을 전해줄 수 있다
- *게이트웨이* : 다음 라우터의 IP 주소가 기록됨
- *넷마스크* : IP 주소의 네트워크 번호와 호스트 번호의 경계를 결정하는 값(기본 게이트웨이가 0.0.0.0으로 등록되어있음)
**프로토콜**
- 패킷의 내용물을 어디서 의뢰받은 것인지 표기한다
- 규칙에 의해 값들이 이미 결정돼있음
- TCP는 `06`, UDP는 `17` (16진수 표기)

#### 4) 이더넷용 MAC 헤더를 만든다
- IP 헤더 제작 후에는 MAC 헤더를 만든다
- 이더넷에는 TCP/IP 개념이 통용되지 않고, 이더넷의 수신처 판단 구조로 사용하는 것이 MAC 헤더는 `동, 번지` 같은 그룹화된 개념이지만, MAC주소는 한 개의 값으로 생각해야 한다

 **MAC 헤더 만들기**
- 맥 헤더는 이더 타입, 수신처 MAC주소, 송신처 MAC 주소를 포함한다
	- `이더 타입`: 프로토콜이 무엇인지 나타낸다
	- `송신처 MAC 주소` : 자체 LAN 어댑터의 MAC 주소
		- 제조시 ROM에 들어가있음
	- `수신처 MAC 주소` : 라우팅 테이블을 통해 패킷을 줄 상대를 조사한다
		- 라우팅 테이블을 통해 패킷을 줄 상대를 조사한다
		- 상대의 MAC 주소를 조사해서 헤더에 기록하면 된다

#### 5) ARP로 수신처 라우터의 MAC 주소를 조사한다

- 상대의 MAC 주소를 조사할 때 쓰이는 것이 ARP
- 이더넷에는 연결돼있는 전체에게 패킷을 전달하는 브로드캐스트라는 구조가 있어서, 이를 이용해 상대가 같은 네트워크에 존재한다면 MAC 주소를 알 수 있다

![[Pasted image 20240325193559 1.png]]

**ARP 캐시**
- 한 번 조사한 결과는 ARP 캐시라는 메모리 영역에 보존해 다시 이용한다
- 우선적으로 ARP 캐시를 조회한 후, ARP 조회를 진행합니다

#### 6) 이더넷의 기본

- 다수의 컴퓨터가 여러 상대와 자유롭게 적은 비용으로 통신하기 위해 고안된 통신 기술
- 이친구 역시 패킷 내용물을 보지 않는다

**이더넷의 원형**
- 네트워크는 사실 케이블이다
- 트랜시버라는 기기도 있는데, 일반 케이블과 유사하게 연결된 케이블 사이에 신호를 흘리는 역할을 한다
- 한 대가 신호를 보내면, 연결된 전원이 신호를 받고, 수신처 주소를 통해 해당하는 기기만 패킷을 수신하고 나머지는 폐기한다

**리피터 허브를 이용한 파생형**
- 트렁크 케이블이 리피터 허브로, 트랜시버 케이블이 트위스티드 페어 케이블로 바뀜
- 여전히 신호가 전원에게 전달 됨

**스위칭 허브를 이용한 형태**
- 스위칭 허브를 수신처 MAC 주소에 따라 목적지를 확인하고 패킷을 중계해서 목적지를 확인하고 패킷을 중계해서 신호는 원하는 상대에게만 흐름

#### 7) IP 패킷을 전기나 빛의 신호로 변환하여 송신한다

- 

#### 8) 패킷에 3개의 제어용 데이터를 추가한다
LAN 드라이버는 IP 담당하는 부분에서 패킷을 받으면 LAN 어댑터의 버퍼 메모리에 복사합니다
이후에는 MAC 회로에 명령을 보낸 다음, MAC 회로에서 작업이 시작되는데...


#### 9) 허브를 향해 패킷을 송신한다


#### 10) 돌아온 패킷을 받는다


#### 11) 서버의 응답 패킷을 IP에서 TCP로 넘긴다
- IP 담당 부분은 IP 헤더를 통해 수신처 IP를 조사하고
- 수신처 IP 주소와 수신한 LAN 어댑터에 할당된 주소가 있는지 확인하고 패킷을 수신한다

**ICMP**
- 이 때, 만약 수신처 IP 주소가 다르다면 오류가 있는 것이다
- 이러한 경우 IP 담당 부분이 ICMP라는 메시지 통신 상대에게 보내 오류를 통지한다
- 여러 타입 있음

**조각 나누기**
- 수신처 주소가 올바르면 수신하나, 패킷을 짧게 하기 위해 얘를 여러개로 나눈다(자세한건 다음 장에서)

**리어셈블링**
- 수신된 패킷이 분할된 것이면, IP 담당 부분은 이를 되돌린다

- 분할된 패킷은 IP 헤더에 있는 플래그라는 항목을 보면 알 수 있다
- 수신 패킷은 분할된 것이라면 IP 담당 부분 내부 메모리에 일시적으로 보관한다
- 분할된 IP 헤더에 있는 ID 정보의 값이 모두 같아 이를 참조해 다른 패킷을 기다린다
- 분할 패킷이 모두 도착하면.. 그때 리어샘블링!

**리어셈블링 이후**
- 패킷을 TCP 담당 부분에 전달
- IP 헤더에 기록된 수신처 IP, 송신처 IP, TCP 헤더에 기록된 수신처 포트 번호, 송신처 포트 번호를 조사해서 해당되는 소켓을 찾는다
- 해당 소켓을 찾은 후, 통신 진행 상태 기록을 기반으로 적절한 동작을 실행

### 6. UDP를 이용한 송수신 동작

![[Pasted image 20240318163536.png]]
#### 1) 수정 송신이 필요없는 데이터의 송신은 UDP가 효율적
- 데이터를 전부 보낸 다음, 수신 측에 수신 확인 응답을 받는다
	- 도착 안하면 다시 보낸다~
- 확실한 데이터를 효율적으로 보내기 위해 사용
	- 데이터 양이 작은 경우, TCP처럼 복잡한 구조 필요 없이 전부 보냄 된다~

#### 2) 제어용 짧은 데이터
- DNS 서버에 대한 조회 등, 제어용으로 실행하는 정보 교환은 하나의 패킷으로 끝나는 경우가 많아 UDP를 사용한다
- 오류 발생시 답이 안돌아오면, 다시 보내면 된다!
- 수신 과정도 간단
	- *송신처 IP와 포트*, *수신처 IP와 포트* 네 항목과 *소켓에 기록된 정보*를 결합하여 데이터를 건네줄 어플리케이션을 판단하고 데이터를 건네기만 하면 됨

#### 3) 음성 및 동영상 데이터
- 음성이나 영상은 정해진 시간 안에 데이터를 건네주어야 한다
- 데이터가 조금 없어도 잠깐 끊기는 것이 괜찮다면, 다시 보내줄 필요 없이 UDP로 보낸다

~~어우 양 많다~~