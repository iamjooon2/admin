## 브라우저 주소창에 www.google.com을 치면 일어나는 일

### 1. 브라우저는 주소창에 입력된 URL을 해석하여, HTTP GET Request 메시지를 작성한다

URL을 해독하여 원격지에서 조회할 웹 서버와 파일명, 포트번호를 판단 후 HTTP 포맷에 맞게 GET 리퀘스트 메시지를 작성한 후, 포맷에 맞는 상태라인, 헤더, 바디를 가지고있는 GET 요청 메시지를 작성한다.


### 2. 브라우저가 DNS 요청을 OS에 의뢰하고 실행한다.

DNS는 도메인 주소와 IP 주소를 대응시키기 위한 서버다.
인터넷 세상에는 막대한 수의 서버가 있어 이것을 모두 1대의 DNS 서버에 등록하는 것은 사실상 불가능하기에, 도메인을 `.`으로 분리해 계층화된 도메인 정보를 DNS 서버에 정보를 분산시켜 다수가 DNS 서버에 등록된다.
그리고 DNS 조회 요청이 오면 URL에 해당하는 부분을 따라가며 DNS서버가 연대하여 정보가 어디 등록되어있는지 찾아내는 구조를 가지고 있다.

DNS 요청은 UDP 프로토콜이고, DNS 서버의 IP 주소는 TCP/IP 설정 항목 중 하나라, OS가 이미 알고있다. 엑세스 대상의 웹 서버가 DNS에 등록되어 있으면 IP 주소를 포함한 응답이 오고, 응답은 OS의 DNS 리졸버가 내용을 해석한 후 IP 주소를 추출하여 메모리에 젖아하고 브라우저의 프로세스가 접근할 수 있도록 한다.

이때, 직접 네트워크 요청을 할 수 없고, DNS 요청을 포함한 모든 네트워크 요청은 OS에 의뢰해 진행한다.

### 3. 브라우저가 OS의 프로토콜 스택에 메시지 송신을 의뢰하고, 소켓을 작성한다.

TCP/IP에 사용되는 프로토콜 스택의 실제 구현체는 OS단에 존재한다.

소켓은 두 단말의 통신 동작을 제어하기 위한 제어 정보의 총체다.(통신 제어 정보를 기록하는 메모리 영역을 가르키는 말이기도 하다)
클라이언트에서는 DNS 조회로 IP 주소를 알아내면 지정된 포트 번호는 서버 컴퓨터의 프로세스를 특정하기 때문에 서버측 컴퓨터의 어떤 소켓과 접속할지 지정할 수 있다.

### 4. TCP 프로토콜 스택은 3-Way Handshake를 통해 서버와의 연결을 설립한다.
TCP 프로토콜은 3-Way Handshake 악수를 통해 SYN과 ACK 비트를 주고받으면서 각 단말이 통신 가능한 상태인지 확인한다. 과정은 다음과 같다.

1. 송신처에서 접속 요청 프로세스가 SYN 비트를 1로 만들어 연결 메시지를 전송한다.
2. TCP 헤더를 받은 서버는 포트 번호에 해당하는 소켓을 찾고 필요한 정보를 기록해서 접속 동작이 진행된다. 서버가 요청을 수락하면 수신처도 SYN 비트를 1, ACK 비트를 1로 만들어 재전송한다.
3. 서버에서 돌아오는 헤더를 받은 프로세스에서는 SYN이 1이면 접속 성공으로 소켓의 서버 IP 주소 혹은 포트 번호등과 함꼐 소켓에 접속 완료를 나타내는 제어 정보를 기록한다.
4. 마지막으로 클라이언트는 패킷을 받았다는 것을 알리기 위해 ACK 비트를 1로 만든 TCP 헤더를 반송한다.

이때, 통신 프로토콜이 https라면 https(tls) 핸드쉐이크도 TCp 핸드쉐이크에 이어서 진행한다.

### 5. TCP 프로토콜 스택에서 패킷을 만들고 TCP 헤더를 붙인다.
핸드쉐이크를 통해 접속이 성립되었으면 서버로 보내야하는 데이터(Http 메시지)를 TCP로 보낼 수 있는 최대치(MMS, maximum segment size)에 맞추어 데이터를 알맞게 자르고 자른 데이터들마다 TCP 헤더를 붙여 몇번째 데이터인지 등등 제어 정보를 덧붙인다. 첫번째로 데이터를 조각낸 패킷을 만든다.

TCP 헤더의 주요한 정보들로는 송수신처의 포트 번호, 데이터 오프셋(데이터의 시작지점), ACK 번호, 6비트짜리 컨트롤 비트(URG, ACK, FIN, SYN, PSH, RST)가 있다

### 6. IP 프로토콜 스택은 패킷을 더 잘게 나누고 원격지의 MAC 주소를 기반으로 한 MAC 헤더를 붙인다
TCP에서 만든 패킷의 기본적인 단위들을 회선과 네트워크 상황에 맞게 MTU를 기반으로 더 잘게 나누고 더 잘게 나눠진 패킷들에 IP 헤더를 붙인다. 헌데 단말이 소통하려면 IP 주소 뿐 아니라 단말이 가진 네트워크 인터페이스(LAN 카드)의 고유한 MAC 주소가 필요하다.

ARP(Address Resolution Protocol)은 IP 주소를 기반으로 MAC 주소를 알아오는 역할을 한다. ARP는 일단 먼저 같은 네트워크 내부에서 브로드캐스트로 요청을 보내 원격지 서버가 네트워크 내부에 있으면 해당 단말의 MAC 주소를, 외부에 있으면 네트워크 라우터의 MAC 주소를 가져온다. 알아낸 주소를 토대로 MAC 헤더를 패킷들마다 만들어 붙인다.

IP 헤더의 주요 정보로는 수신처 IP 주소, 4계층 프로토콜 종류, 송신처 IP 주소, 플래그(패킷이 조각으로 나뉜 것인지, 조각으로 나누는 것이 가능한지), 프래그먼트 오프셋(이 패킷의 데이터 부분이 메시징의 맨 앞부분부터 몇번째 바이트인지를 나타낸다) 등이 있다.

### 7. LAN 어댑터를 통해 바이너리 데이터를 전기 신호로 바꾼다.
송신측에서 패킷 읽을 타이밍을 잡을 때 쓰는 프리앰블 비트, 패킷의 개시 위치가 어디인서부터인지를 알게 해주는 비트, 패킷 오류 검출을 위한 FCS 비트 등 데이터를 추가하여 이진 데이터를 전기신호로 바꾼다.

이때 LAN 어댑터가 컴퓨터에 무조건 꽂혀있어야만 인터넷을 사용할 수 있는 것은 아니다. 와이파이 혹은 휴대폰 데이터를 사용한 무선 통신으로도 인터넷을 이용할 수 있다.

### 8. 원격지의 MAC 주소로 전기 신호를 송출한다.
전기 신호를 LAN 케이블을 통해 송출한다. 데이터가 집 밖으로 나가는 순간이다.
이때 원격지가 대역폭이 다른 외부 네트워크라면 패킷은 네트워크의 라우터로, 대역폭이 다른 내부 네트워크라면 해당 원격지로 전송된다.

전기 신호가 같은 네트워크 내부를 돌면서 원격지 서버를 찾아갈 때, 스위치라는 2계층의 장비를 만날 수 있다. 스위치 하나에 여러개의 단말이 붙어있는 꼴이고, 이 스위치들을 모아 네트워크를 만들 수 있다. 스위치는 패킷의 맨 끝 FCS를 대조하여 패킷 오류의 유무를 검사하기도 하고, 맥 주소 테이블을 통해 해당 스위치에 붙은 단말이 패킷의 목적지인지 검사합니다.

스위치는 연결된 단말의 모든 MAC 주소를 알고 있어 본래 브로드캐스팅이라 이론적으로는 모든 단말에 닿아야 하는 ARP 요청같은 것들도 스위치에서 알아서 걸러준다.

* N 계층 장비?
- 패킷에 계층별로 붙였던 동작을 설명한 것처럼 헤더와같은 제어 정보들을 N계층까지 확인할 수 있는 장비들을 말한다. 2계층 장비인 스위치는 MAC 헤더의 정보를 확인해볼 수 있고, 3계층 장비인 라우터는 MAC 헤더와 더불어 IP 헤더의 정보를 확인할 수 있는 방식같이 패킷을 어디까지 까 볼수있느냐 차이이다.

### 9. 패킷의 목적지가 외부 네트워크일 시, 라우터에 패킷이 도달한다.
라우터에 도착한 패킷은 연결된 포트를 통해 다른 네트워크에 존재하는 원격지 MAC 주소를 알아내기 위해 ARP를 원격지에 요청하고 라우팅 테이블을 뒤져 패킷을 중개하기 위한 경로를 탐색하고 전기 신호를 송신한다.

라우팅 테이블은 수신처의 정보(IP 주소, 서브넷 마스크, 게이트웨이)와 수신처까지의 거리 등의 정보를 기록하는 표이다. 라우터는 이 항목에 등록되어있는 IP 주소와 수신한 패킷의 수신처 IP를 비교하여 패킷을 어디로 보낼지 최적의 경로를 찾아준다. 이때 라우터는 회선 상황에 맞추어 패킷을 더 나누기도 한다.

### 10. 액세스 회선, 인터넷 접속용 라우터를 통과하여 인터넷의 내부로 중개된다.
라우터를 나간 패킷은 인터넷의 엑세스 회선을 통과하며 장거리 통신에 적합한 형태로 변형되고, 추가적인 제어 정보를 붙여 인터넷에 내부로 중계된다.
엑세스 회선의 종류에 따라 세부 동작이 다른데, FTTH 엑세스 회선을 쓸 경우 광섬유, 광통신에 알맞는 형태로 변형된다.

이 단계에서 전기 신호는 건물의 배선을 지나서 전화 케이블로 들어가게 된다. 전신주를 타고 이 전기 신호들은 통신사의 전화국으로 들어간 후, 거기서 또 인터넷 접속용 라우터를 거쳐 인터넷의 내부로 중계되기 시작한다.

### 11. 인터넷 내부에서의 패킷의 여정
인터넷은 단일 네트워크가 아닌 다수의 인터넷 사업자(프로바이더)가 네트워크를 서로 접속한 것이다.

ADSL이나 FTTH의 엑세스 회선은 사용자가 계약한 프로바이더의 설비에 연결되어 있다. 통신사 인터넷에 가입하면 이런 통신사 설비에 연결된 고유한 IP 주소나 회선을 쉽게 얻을 수 있다. 쉽게 여러 통신사의 무수한 라우터들이 인터넷을 이루고 있다고 생각할 수 있다.

여러 프로바이더의 여러 라우팅 장비들을 거치면서 최종적으로 목적지 서버가 포함된 네트워크의 라우터를 거쳐 해당 목적지 웹 서버의 단말로 패킷이 도착된다.

이때 여러 프로바이더를 거치며 전기 신호가 [해저케이블을 통해 바다를 건너기도 한다](https://www.submarinecablemap.com/)

### 12. 웹 서버로 전기 신호가 도착한 이후의 동작
전기 신호를 받은 웹 서버의 LAN 어댑터가 전기 신호를 이진 데이터로 바꾼다.
네트워크 인터페이스에서 수신된 패킷의 MAC 주소를 비교하고 FCS로 패킷 훼손이 없는지 판단하여 올바른 패킷인 경우 OS단의 프로토콜 스택으로 올려보낸다.

프로토콜 스택의 IP 담당 부분에서는 IP 헤더를 바탕으로 잘려서 온 패킷을 다시 조립한 후, IP 주소가 제대로 된게 맞는지 검증한 후 TCP 담당 부분으로 전달한다.
이때 패킷 IP 헤더의 플래그, 오프셋 항목을 참조한다.

TCP 담당 부분은 TCP 헤더를 토대로 데이터가 잘려있는 패킷들을 다시 완성된 데이터로 만들고 해당 패킷을 잘 받았다면 클라이언트에 수신 확인 응답용 ACK 번호를 반송한다. TCP 헤더의 시퀀스 번호를 참조한다.

완성된 데이터를 만들었으면 제어 정보와 포트 번호를 토대로 TCP Handshake를 만들어놓은 적합한 소켓을 찾는다. 완성된 데이터를 소켓에 기록해 어플리케이션의 프로세스에 건내준다.

* 네트워크 계층을 올라가며 전기 신호를 바탕으로 조각난 패킷과 헤더 정보를 바탕으로 클라이언트에서 발송한 데이터를 재조립하는 디캡슐레이션 동작이다

### 13. 서버 어플리케이션은 완성된 요청 메시지를 받고, 응답 메시지를 작성한다.
서버 어플리케이션이 http 요청 메시지를 받으면, 요청 URI를 실제 서버의 파일 시스템에서 URI로 바꿔 해당되는 html 자원을 찾아 바디를 넣은 후 리스퐅스 헤더와 함께 응답 메시지를 작성한다. 엔드포인트와 웹 서버의 디렉토리는 차이가 있을 수 있기에 서버에서 올바르게 찾아주는 과정이 필요하다.

클라이언트에서 처럼, 서버도 똑같이 프로토콜 스택을 다시 내려가며 패킷 처리를 하고 인터넷과 라우터들을 거쳐 다시 응답 메시지를 클라이언트에게 반송한다.

### 14. 응답을 받은 클라이언트의 동작
클라이언트의 브라우저는 HTTP 메시지의 content-type 헤더를 보고 html임을 알아낸 후, 브라우저가 화면 표시 동작을 실행한다.

### 15. 요청이 종료되었다면 4-Way Handshake를 통해 접속을 끊고 소켓을 말소한다.
데이터 송수신 과정이 끝났다면 접속을 끊기 위해 4-way Handshake를 실시한다.
1. 요청-응답이 완료되었다면 서버측에서는 TCP 헤더의 FIN 비트에 1을 설정해 연결이 끝났음을 클라이언트에게 알린다.
2. 클라이언트는 FIN 비트를 받아 서버측이 소켓 연결을 해제하고 있음을 확인한 후, ACK 번호를 서버에 반송한다
3. 클라이언트는 이때 서버에서 보낸 데이터를 전부 수신완료했다는 사실을 어플리케이션에 알린 후, 데이터 송수신 동작을 정리한다.
4. 클라이언트 측의 프로콜 스택이 FIN 1 TCP 헤더를 만들어 서버에 송신한 후, ACK가 돌아오면 서버와의 접속이 종료된다. 이후 소켓을 말소한다

* HTTP 1.1부터 도입된 Keep-Alive 때문에 요청이 끝났더라도 커넥션이 바로 종료되지 않는 것이 일반적이고, keep-alive timeout 설정이 지나고 난 후에 서버-클라이언트간 접속이 끊어지고 소켓이 만료된다.


#### Ref
[성공과 실패를 결정하는 1%의 네트워크 원리], 성안당
https://maxkim-j.github.io/posts/packet-travel
https://www.youtube.com/watch?v=GAyZ_QgYYYo