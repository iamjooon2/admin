### MySQL 엔진 아키텍쳐

MySQL 서버는 크게 **MYSQL 엔진**과 **스토리지 엔진**으로 나눌 수 있다.

MySQL 엔진은 `클라이언트로부터의 접속 및 쿼리 요청을 처리하는 
커넥션 핸들러와 SQL 파서 전처리기`, 쿼리의 `최적화된 실행을 위한 옵티마이저`가 중심을 이룬다.
쿼리 관련 처리를 하는 곳이기에 `DBMS의 두뇌`인 셈이다.

스토리지 엔진은 `디스크 스토리지에 저장`하거나, `디스크 스토리지로부터 데이터를 읽어오는 작업`을 한다.

두 엔진은 `핸들러 API`를 통해 데이터를 주고받는다. 핸들러 API의 작업 내역은 아래 명령을 통해 확인할 수 있다.
```sql
SHOW GLOBAL STATUS LIKE 'HANDLER%';
```

### MySQL 스레딩 구조

MySQL 서버는 프로세스가 아닌 스레드 기반으로 작동하며, 크게 **백그라운드 스레드**와 **포그라운드 스레드**로 구분할 수 있다.
실행중인 스레드 목록은 아래 명령을 통해 확인할 수 있다.
```sql
SELECT thread_id, name, type, processlist_user, processlist_host
FROM performance_schema.threads ORDER BY type, thread_id;
```

포그라운드 스레드는 **MySQL 서버에 접속된 클라이언트의 수만큼 존재**하며, 주로 각 **클라이언트 사용자가 요청하는 쿼리를 수행**한다.
데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오고, 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다. InnoDB의 경우 `데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리`하고, 나머지 `버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리`한다.

InnoDB의 경우 백그라운스 스레드로 처리되는 작업은 다음과 같다.
- 인서트 버퍼(insert buffer)를 병합
- **로그를 디스크로 기록(Log Thread)**
- **InnoDB 버퍼 풀의 데이터를 디스크에 기록(Write Thread)**
- 데이터를 버퍼로 읽어옴
- 데드락, 잠금 모니터링

사용자 요청 처리 중 쓰기 작업은 지연될 수 있지만, 읽기 요청은 지연될 수 없다.
대부분의 상용 DBMS는 대부분 쓰기 작업을 버퍼링 해서 일괄 처리하는 기능이 탑재되어 있으며, InnoDB도 이 방식을 사용하기 때문에 INSERT, UPDATE, DELETE 쿼리 작성시 데이터가 완전히 디스크 파일로 저장되기 전까지 기다리지 않아도 된다.

### 메모리 할당 및 사용 구조
MySQL에서 사용하는 메모리 공간은 크게 **글로벌 메모리 영역**과 **로컬 메모리 영역(==세션 메모리 영역)** 으로 구분된다.
 
글로벌 메모리 영역의 경우 `MySQL 서버가 시작되면서 OS로부터 할당`되며, OS마다 조금씩 정책이 다르다. 글로벌 메모리 영역은 단 하나의 메모리 공간만 할당받으며, 모든 스레드에게 공유된다.
 
반면, 로컬 메모리 영역의 경우 `스레드당 하나씩 생성`되며, 공유되지 않고 사용된다.
쿼리의 용도별로 공간이 할당되고, 필요하지 않으면 아예 메모리 공간 자체가 생성되지 않을 수도 있기 때문에 (정렬이나 조인 버퍼 같은 경우) 주의해야 한다.

### 쿼리 실행 구조

- 쿼리 파서
쿼리 파서는 `사용자에게 입혁받은 쿼리를 MySQL이 인식할 수 있는 토큰으로 분리하여 트리 형태의 구조로 만든다.` 쿼리 문법의 기본적인 문법 오류가 이 과정에서 발견된다.

- 전처리기
`파서 과정에서 만들어진 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인`한다.
실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰을 이 단계에서 검증한다.

- 옵티마이저
쿼리 문장을 가장 저렴한 비용으로 처리하기 위한 최적화를 진행한다. 매우 중요하다.

- 실행 엔진
만들어진 계획대로 각 핸들러에게 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다.

`GROUP BY`를 처리하기 위해 임시 테이블을 사용한다고 할 때, 과정은 다음과 같다.
  1. 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청한다.
  2. 다시 실행 엔진은 `WHERE` 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청한다.
  3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청한다.
  4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어오라고 핸들러에게 다시 요청한다.
  5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘긴다.

- 핸들러(==스토리지 엔진)
실행 엔진의 요청에 따라 `데이터를 디스크로 저장하거나, 디스크로부터 읽어온다`

### 스레드 풀
아래 내용은 Percona Server의 스레드 풀 기능이다.
스레드 풀은 서버의 자원 소모를 줄이는데 그 목적이 있다. 한 마디로 정리하면, `동시에 실행중인 스레드를 CPU가 최대한 잘 처리할 수 있는 수준으로 줄여서 빨리 처리하는 기능`이다.

- thread_pool_size
Percona Server에서는 기본적으로 **CPU 코어 수만큼 스레드 그룹을 생성**하며, thread_pool_size 시스템 변수를 수정하여 조정이 가능하다.
 
- thread_pool_oversubscribe
만약, 이미 스레드 풀이 처리하는 작업이 있으면 **thread_pool_oversubscribe 변수를 통해 얼마나 더 추가로 처리할지 설정가능**하다. (스케줄링해야 하는 스레드 수가 많아지기 때문에, 무작정 늘리는 것도 좋지 않다.) 기본값은 3이다.
 
- thread_pool_stall_limit
스레드 그룹 내의 모든 스레드가 일을 처리하고 있다면 해당 스레드 그룹에 새로운 Worker Thread를 추가할지, 아니면 기존 작업이 끝날 때까지 기다릴지 판단해야 한다. 스레드 풀 내의 타이머 스레드는 스레드 그룹의 상태를 주기적으로 체크하여 thread_pool_stall_limit 변수에 정의된 초만큼 작업 스레드가 처리 중인 작업이 끝나지 않았을 때 새로운 스레드를 생성해서 추가하도록 만든다. 당연하게도 이 수는 할당 가능한 전체 스레드 수 (thread_pool_max_threads)를 넘을 수 없다.